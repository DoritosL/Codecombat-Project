{"version":3,"sources":["bower_components/treema/treema.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"public/javascripts/app/vendor/treema.js","sourcesContent":["var TreemaNode,\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  __slice = [].slice;\n\nTreemaNode = (function() {\n  var defaults;\n\n  TreemaNode.prototype.schema = {};\n\n  TreemaNode.prototype.$el = null;\n\n  TreemaNode.prototype.data = null;\n\n  TreemaNode.prototype.options = null;\n\n  TreemaNode.prototype.parent = null;\n\n  TreemaNode.prototype.lastSelectedTreema = null;\n\n  TreemaNode.prototype.treemaFilterHiddenClass = 'treema-filter-hidden';\n\n  TreemaNode.prototype.nodeTemplate = '<div class=\"treema-row treema-clearfix\"><div class=\"treema-value\"></div></div>';\n\n  TreemaNode.prototype.childrenTemplate = '<div class=\"treema-children\"></div>';\n\n  TreemaNode.prototype.addChildTemplate = '<div class=\"treema-add-child\" tabindex=\"9009\">+</div>';\n\n  TreemaNode.prototype.tempErrorTemplate = '<span class=\"treema-temp-error\"></span>';\n\n  TreemaNode.prototype.toggleTemplate = '<span class=\"treema-toggle-hit-area\"><span class=\"treema-toggle\"></span></span>';\n\n  TreemaNode.prototype.keyTemplate = '<span class=\"treema-key\"></span>';\n\n  TreemaNode.prototype.errorTemplate = '<div class=\"treema-error\"></div>';\n\n  TreemaNode.prototype.newPropertyTemplate = '<input class=\"treema-new-prop\" />';\n\n  TreemaNode.prototype.collection = false;\n\n  TreemaNode.prototype.ordered = false;\n\n  TreemaNode.prototype.keyed = false;\n\n  TreemaNode.prototype.editable = true;\n\n  TreemaNode.prototype.directlyEditable = true;\n\n  TreemaNode.prototype.skipTab = false;\n\n  TreemaNode.prototype.valueClass = null;\n\n  TreemaNode.prototype.removeOnEmptyDelete = true;\n\n  TreemaNode.prototype.keyForParent = null;\n\n  TreemaNode.prototype.childrenTreemas = null;\n\n  TreemaNode.prototype.integrated = false;\n\n  TreemaNode.prototype.workingSchema = null;\n\n  TreemaNode.prototype.nodeDescription = 'Node';\n\n  TreemaNode.prototype.isValid = function() {\n    var errors;\n    errors = this.getErrors();\n    return errors.length === 0;\n  };\n\n  TreemaNode.prototype.getErrors = function() {\n    var e, errors, moreErrors, my_path, root, _i, _len;\n    if (!this.tv4) {\n      return [];\n    }\n    if (this.isRoot()) {\n      if (this.cachedErrors) {\n        return this.cachedErrors;\n      }\n      this.cachedErrors = this.tv4.validateMultiple(this.data, this.schema)['errors'];\n      return this.cachedErrors;\n    }\n    root = this.getRoot();\n    errors = root.getErrors();\n    my_path = this.getPath();\n    errors = (function() {\n      var _i, _len, _results;\n      _results = [];\n      for (_i = 0, _len = errors.length; _i < _len; _i++) {\n        e = errors[_i];\n        if (e.dataPath.slice(0, +my_path.length + 1 || 9e9) === my_path) {\n          _results.push(e);\n        }\n      }\n      return _results;\n    })();\n    for (_i = 0, _len = errors.length; _i < _len; _i++) {\n      e = errors[_i];\n      if (e.dataPath === my_path) {\n        e.subDataPath = '';\n      } else {\n        e.subDataPath = e.dataPath.slice(0, +my_path.length + 1 || 9e9);\n      }\n    }\n    if (this.workingSchema) {\n      moreErrors = this.tv4.validateMultiple(this.data, this.workingSchema).errors;\n      errors = errors.concat(moreErrors);\n    }\n    return errors;\n  };\n\n  TreemaNode.prototype.setUpValidator = function() {\n    var root, _ref;\n    if (!this.parent) {\n      this.tv4 = (_ref = window['tv4']) != null ? _ref.freshApi() : void 0;\n      this.tv4.addSchema('#', this.schema);\n      if (this.schema.id) {\n        return this.tv4.addSchema(this.schema.id, this.schema);\n      }\n    } else {\n      root = this.getRoot();\n      return this.tv4 = root.tv4;\n    }\n  };\n\n  TreemaNode.prototype.saveChanges = function(oldData) {\n    if (oldData === this.data) {\n      return;\n    }\n    return this.addTrackedAction({\n      'oldData': oldData,\n      'newData': this.data,\n      'path': this.getPath(),\n      'action': 'edit'\n    });\n  };\n\n  TreemaNode.prototype.getChildSchema = function(key) {\n    return TreemaNode.utils.getChildSchema(key, this.workingSchema);\n  };\n\n  TreemaNode.prototype.buildValueForDisplay = function() {\n    return console.error('\"buildValueForDisplay\" has not been overridden.');\n  };\n\n  TreemaNode.prototype.buildValueForEditing = function() {\n    if (!(this.editable && this.directlyEditable)) {\n      return;\n    }\n    return console.error('\"buildValueForEditing\" has not been overridden.');\n  };\n\n  TreemaNode.prototype.getChildren = function() {\n    return console.error('\"getChildren\" has not been overridden.');\n  };\n\n  TreemaNode.prototype.canAddChild = function() {\n    return this.collection && this.editable && !this.settings.readOnly;\n  };\n\n  TreemaNode.prototype.canAddProperty = function() {\n    return true;\n  };\n\n  TreemaNode.prototype.addingNewProperty = function() {\n    return false;\n  };\n\n  TreemaNode.prototype.addNewChild = function() {\n    return false;\n  };\n\n  TreemaNode.prototype.buildValueForDisplaySimply = function(valEl, text) {\n    if (text.length > 200) {\n      text = text.slice(0, 200) + '...';\n    }\n    return valEl.append($(\"<div></div>\").addClass('treema-shortened').text(text));\n  };\n\n  TreemaNode.prototype.buildValueForEditingSimply = function(valEl, value, inputType) {\n    var input;\n    if (inputType == null) {\n      inputType = null;\n    }\n    input = $('<input />');\n    if (inputType) {\n      input.attr('type', inputType);\n    }\n    if (value !== null) {\n      input.val(value);\n    }\n    valEl.append(input);\n    input.focus().select();\n    input.blur(this.onEditInputBlur);\n    return input;\n  };\n\n  TreemaNode.prototype.onEditInputBlur = function(e) {\n    var closest, input, shouldRemove;\n    shouldRemove = this.shouldTryToRemoveFromParent();\n    closest = $(e.relatedTarget).closest('.treema-node')[0];\n    if (closest === this.$el[0]) {\n      shouldRemove = false;\n    }\n    this.markAsChanged();\n    this.saveChanges(this.getValEl());\n    input = this.getValEl().find('input, textarea, select');\n    if (this.isValid()) {\n      if (this.isEditing()) {\n        this.display();\n      }\n    } else {\n      input.focus().select();\n    }\n    if (shouldRemove) {\n      this.remove();\n    } else {\n      this.flushChanges();\n    }\n    return this.broadcastChanges();\n  };\n\n  TreemaNode.prototype.shouldTryToRemoveFromParent = function() {\n    var input, inputs, val, _i, _len;\n    val = this.getValEl();\n    if (val.find('select').length) {\n      return;\n    }\n    inputs = val.find('input, textarea');\n    for (_i = 0, _len = inputs.length; _i < _len; _i++) {\n      input = inputs[_i];\n      input = $(input);\n      if (input.attr('type') === 'checkbox' || input.val()) {\n        return false;\n      }\n    }\n    if (!this.getErrors().length) {\n      return false;\n    }\n    return true;\n  };\n\n  TreemaNode.prototype.limitChoices = function(options) {\n    var _this = this;\n    this[\"enum\"] = options;\n    this.buildValueForEditing = function(valEl, data) {\n      var index, input, option, _i, _len, _ref;\n      input = $('<select></select>');\n      _ref = _this[\"enum\"];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        option = _ref[_i];\n        input.append($('<option></option>').text(option));\n      }\n      index = _this[\"enum\"].indexOf(data);\n      if (index >= 0) {\n        input.prop('selectedIndex', index);\n      }\n      valEl.append(input);\n      input.focus();\n      input.blur(_this.onEditInputBlur);\n      return input;\n    };\n    return this.saveChanges = function(valEl) {\n      var index;\n      index = valEl.find('select').prop('selectedIndex');\n      _this.addTrackedAction({\n        'oldData': _this.data,\n        'newData': _this[\"enum\"][index],\n        'path': _this.getPath(),\n        'action': 'edit'\n      });\n      _this.data = _this[\"enum\"][index];\n      TreemaNode.changedTreemas.push(_this);\n      return _this.broadcastChanges();\n    };\n  };\n\n  TreemaNode.pluginName = \"treema\";\n\n  defaults = {\n    schema: {},\n    callbacks: {}\n  };\n\n  function TreemaNode($el, options, parent) {\n    this.$el = $el;\n    this.parent = parent;\n    this.onSelectType = __bind(this.onSelectType, this);\n    this.onSelectSchema = __bind(this.onSelectSchema, this);\n    this.orderDataFromUI = __bind(this.orderDataFromUI, this);\n    this.onMouseLeave = __bind(this.onMouseLeave, this);\n    this.onMouseEnter = __bind(this.onMouseEnter, this);\n    this.onEditInputBlur = __bind(this.onEditInputBlur, this);\n    this.setWorkingSchema(options.workingSchema, options.workingSchemas);\n    delete options.workingSchema;\n    delete options.workingSchemas;\n    this.$el = this.$el || $('<div></div>');\n    this.settings = $.extend({}, defaults, options);\n    this.schema = $.extend({}, this.settings.schema);\n    this.data = options.data;\n    this.defaultData = options.defaultData;\n    this.keyForParent = options.keyForParent;\n    this.patches = [];\n    this.trackedActions = [];\n    this.currentStateIndex = 0;\n    this.trackingDisabled = false;\n    this.callbacks = this.settings.callbacks;\n    this._defaults = defaults;\n    this._name = TreemaNode.pluginName;\n    this.setUpValidator();\n    this.populateData();\n    this.previousState = this.copyData();\n    this.unloadNodeSpecificSettings();\n  }\n\n  TreemaNode.prototype.unloadNodeSpecificSettings = function() {\n    var key, _i, _len, _ref, _results;\n    _ref = ['data', 'defaultData', 'schema', 'type'];\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      key = _ref[_i];\n      if (this.settings[key] != null) {\n        this[key] = this.settings[key];\n      }\n      _results.push(delete this.settings[key]);\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.build = function() {\n    var schema, valEl, _ref;\n    this.$el.addClass('treema-node').addClass('treema-clearfix');\n    this.$el.empty().append($(this.nodeTemplate));\n    this.$el.data('instance', this);\n    if (!this.parent) {\n      this.$el.addClass('treema-root');\n    }\n    if (!this.parent) {\n      this.$el.attr('tabindex', 9001);\n    }\n    if (this.collection) {\n      this.$el.append($(this.childrenTemplate)).addClass('treema-closed');\n    }\n    valEl = this.getValEl();\n    if (this.valueClass) {\n      valEl.addClass(this.valueClass);\n    }\n    if (this.directlyEditable) {\n      valEl.addClass('treema-display');\n    }\n    this.buildValueForDisplay(valEl, this.getData());\n    if (this.collection && !this.parent) {\n      this.open();\n    }\n    if (!this.parent) {\n      this.setUpGlobalEvents();\n    }\n    if (this.parent) {\n      this.setUpLocalEvents();\n    }\n    if (this.collection) {\n      this.updateMyAddButton();\n    }\n    this.createTypeSelector();\n    if (((_ref = this.workingSchemas) != null ? _ref.length : void 0) > 1) {\n      this.createSchemaSelector();\n    }\n    schema = this.workingSchema || this.schema;\n    if (schema[\"enum\"]) {\n      this.limitChoices(schema[\"enum\"]);\n    }\n    this.updateDefaultClass();\n    return this.$el;\n  };\n\n  TreemaNode.prototype.populateData = function() {};\n\n  TreemaNode.prototype.setWorkingSchema = function(workingSchema, workingSchemas) {\n    this.workingSchema = workingSchema;\n    this.workingSchemas = workingSchemas;\n  };\n\n  TreemaNode.prototype.createSchemaSelector = function() {\n    var i, label, option, schema, select, _i, _len, _ref;\n    select = $('<select></select>').addClass('treema-schema-select');\n    _ref = this.workingSchemas;\n    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n      schema = _ref[i];\n      label = this.makeWorkingSchemaLabel(schema);\n      option = $('<option></option>').attr('value', i).text(label);\n      if (schema === this.workingSchema) {\n        option.attr('selected', true);\n      }\n      select.append(option);\n    }\n    select.change(this.onSelectSchema);\n    return this.$el.find('> .treema-row').prepend(select);\n  };\n\n  TreemaNode.prototype.makeWorkingSchemaLabel = function(schema) {\n    if (schema.title != null) {\n      return schema.title;\n    }\n    if (schema.type != null) {\n      return schema.type;\n    }\n    return '???';\n  };\n\n  TreemaNode.prototype.getTypes = function() {\n    var schema, types;\n    schema = this.workingSchema || this.schema;\n    types = schema.type || [\"string\", \"number\", \"integer\", \"boolean\", \"null\", \"array\", \"object\"];\n    if (!$.isArray(types)) {\n      types = [types];\n    }\n    return types;\n  };\n\n  TreemaNode.prototype.createTypeSelector = function() {\n    var currentType, option, schema, select, type, types, _i, _len;\n    types = this.getTypes();\n    if (!(types.length > 1)) {\n      return;\n    }\n    schema = this.workingSchema || this.schema;\n    if (schema[\"enum\"]) {\n      return;\n    }\n    select = $('<select></select>').addClass('treema-type-select');\n    currentType = $.type(this.getData());\n    if (this.valueClass === 'treema-integer') {\n      currentType = 'integer';\n    }\n    for (_i = 0, _len = types.length; _i < _len; _i++) {\n      type = types[_i];\n      option = $('<option></option>').attr('value', type).text(this.getTypeName(type));\n      if (type === currentType) {\n        option.attr('selected', true);\n      }\n      select.append(option);\n    }\n    select.change(this.onSelectType);\n    return this.$el.find('> .treema-row').prepend(select);\n  };\n\n  TreemaNode.prototype.getTypeName = function(type) {\n    return {\n      \"null\": 'null',\n      array: 'arr',\n      number: 'num',\n      string: 'str',\n      integer: 'int',\n      boolean: 'bool',\n      object: 'obj'\n    }[type];\n  };\n\n  TreemaNode.prototype.setUpGlobalEvents = function() {\n    var _this = this;\n    this.$el.unbind();\n    this.$el.dblclick(function(e) {\n      var _ref;\n      return (_ref = $(e.target).closest('.treema-node').data('instance')) != null ? _ref.onDoubleClick(e) : void 0;\n    });\n    this.$el.click(function(e) {\n      var _ref;\n      if ((_ref = $(e.target).closest('.treema-node').data('instance')) != null) {\n        _ref.onClick(e);\n      }\n      return _this.broadcastChanges(e);\n    });\n    this.keysPreviouslyDown = {};\n    this.$el.keydown(function(e) {\n      var closest, lastSelected, _ref;\n      e.heldDown = _this.keysPreviouslyDown[e.which] || false;\n      closest = $(e.target).closest('.treema-node').data('instance');\n      lastSelected = _this.getLastSelectedTreema();\n      if ((_ref = lastSelected || closest) != null) {\n        _ref.onKeyDown(e);\n      }\n      _this.broadcastChanges(e);\n      _this.keysPreviouslyDown[e.which] = true;\n      if (e.ctrlKey || e.metaKey) {\n        return _this.manageCopyAndPaste(e);\n      }\n    });\n    return this.$el.keyup(function(e) {\n      var _ref, _ref1;\n      if ((_ref = e.which) === 17 || _ref === 91) {\n        if ((_ref1 = _this.targetOfCopyPaste) != null) {\n          _ref1.removeClass('treema-target-of-copy-paste');\n        }\n        _this.targetOfCopyPaste = null;\n      }\n      return delete _this.keysPreviouslyDown[e.which];\n    });\n  };\n\n  TreemaNode.prototype.manageCopyAndPaste = function(e) {\n    var el, target, _ref,\n      _this = this;\n    el = document.activeElement;\n    if ((el != null) && (el.tagName.toLowerCase() === 'input' && el.type === 'text') || (el.tagName.toLowerCase() === 'textarea' && !$(el).hasClass('treema-clipboard'))) {\n      return;\n    }\n    target = (_ref = this.getLastSelectedTreema()) != null ? _ref : this;\n    if (e.which === 86 && $(e.target).hasClass('treema-clipboard')) {\n      if (e.shiftKey && $(e.target).hasClass('treema-clipboard')) {\n        this.saveScrolls();\n        return setTimeout((function() {\n          var newData, result;\n          _this.loadScrolls();\n          if (!(newData = _this.$clipboard.val())) {\n            return;\n          }\n          try {\n            newData = JSON.parse(newData);\n          } catch (_error) {\n            e = _error;\n            _this.$el.trigger({\n              type: 'treema-error',\n              message: 'Could not parse pasted data as JSON.'\n            });\n            return;\n          }\n          result = target.tv4.validateMultiple(newData, target.schema);\n          if (result.valid) {\n            target.set('/', newData);\n            return _this.$el.trigger('treema-paste');\n          } else {\n            _this.$el.trigger({\n              type: 'treema-error',\n              message: 'Data provided is invalid according to schema.'\n            });\n            return console.log(\"not pasting\", newData, \"because it's not valid:\", result);\n          }\n        }), 5);\n      } else {\n        return e.preventDefault();\n      }\n    } else if (e.shiftKey) {\n      if (!this.$clipboardContainer) {\n        return;\n      }\n      this.saveScrolls();\n      this.$clipboardContainer.find('.treema-clipboard').focus().select();\n      return this.loadScrolls();\n    } else {\n      this.saveScrolls();\n      if (!this.$clipboardContainer) {\n        this.$clipboardContainer = $('<div class=\"treema-clipboard-container\"></div>').appendTo(this.$el);\n        this.$clipboardContainer.on('paste', function() {\n          var _ref1;\n          return (_ref1 = _this.targetOfCopyPaste) != null ? _ref1.removeClass('treema-target-of-copy-paste') : void 0;\n        });\n        this.$clipboardContainer.on('copy', function() {\n          var _ref1;\n          _this.$el.trigger('treema-copy');\n          return (_ref1 = _this.targetOfCopyPaste) != null ? _ref1.removeClass('treema-target-of-copy-paste') : void 0;\n        });\n      }\n      this.targetOfCopyPaste = target.$el;\n      this.targetOfCopyPaste.addClass('treema-target-of-copy-paste');\n      this.$clipboardContainer.empty().show();\n      this.$clipboard = $('<textarea class=\"treema-clipboard\"></textarea>').val(JSON.stringify(target.getData(), null, '  ')).appendTo(this.$clipboardContainer).focus().select();\n      return this.loadScrolls();\n    }\n  };\n\n  TreemaNode.prototype.broadcastChanges = function(e) {\n    var changes, t, _base;\n    if (this.getRoot().hush) {\n      return;\n    }\n    if (this.callbacks.select && TreemaNode.didSelect) {\n      TreemaNode.didSelect = false;\n      this.callbacks.select(e, this.getSelectedTreemas());\n    }\n    if (TreemaNode.changedTreemas.length) {\n      changes = (function() {\n        var _i, _len, _ref, _results;\n        _ref = TreemaNode.changedTreemas;\n        _results = [];\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          t = _ref[_i];\n          if (t.integrated || !t.parent) {\n            _results.push(t);\n          }\n        }\n        return _results;\n      })();\n      if (typeof (_base = this.callbacks).change === \"function\") {\n        _base.change(e, jQuery.unique(changes));\n      }\n      return TreemaNode.changedTreemas = [];\n    }\n  };\n\n  TreemaNode.prototype.markAsChanged = function() {\n    return TreemaNode.changedTreemas.push(this);\n  };\n\n  TreemaNode.prototype.setUpLocalEvents = function() {\n    var row;\n    row = this.$el.find('> .treema-row');\n    if (this.callbacks.mouseenter != null) {\n      row.mouseenter(this.onMouseEnter);\n    }\n    if (this.callbacks.mouseleave != null) {\n      return row.mouseleave(this.onMouseLeave);\n    }\n  };\n\n  TreemaNode.prototype.onMouseEnter = function(e) {\n    return this.callbacks.mouseenter(e, this);\n  };\n\n  TreemaNode.prototype.onMouseLeave = function(e) {\n    return this.callbacks.mouseleave(e, this);\n  };\n\n  TreemaNode.prototype.onClick = function(e) {\n    var clickedToggle, clickedValue, usedModKey, _ref;\n    if ((_ref = e.target.nodeName) === 'INPUT' || _ref === 'TEXTAREA' || _ref === 'SELECT') {\n      return;\n    }\n    clickedValue = $(e.target).closest('.treema-value').length;\n    clickedToggle = $(e.target).hasClass('treema-toggle') || $(e.target).hasClass('treema-toggle-hit-area');\n    usedModKey = e.shiftKey || e.ctrlKey || e.metaKey;\n    if (!(clickedValue && !this.collection)) {\n      this.keepFocus();\n    }\n    if (this.isDisplaying() && clickedValue && this.canEdit() && !usedModKey) {\n      return this.toggleEdit();\n    }\n    if (!usedModKey && (clickedToggle || (clickedValue && this.collection))) {\n      if (!clickedToggle) {\n        this.deselectAll();\n        this.select();\n      }\n      return this.toggleOpen();\n    }\n    if ($(e.target).closest('.treema-add-child').length && this.collection) {\n      return this.addNewChild();\n    }\n    if (this.isRoot() || this.isEditing()) {\n      return;\n    }\n    if (e.shiftKey) {\n      return this.shiftSelect();\n    }\n    if (e.ctrlKey || e.metaKey) {\n      return this.toggleSelect();\n    }\n    return this.select();\n  };\n\n  TreemaNode.prototype.onDoubleClick = function(e) {\n    var clickedKey, _base, _base1, _base2;\n    if (!this.collection) {\n      return typeof (_base = this.callbacks).dblclick === \"function\" ? _base.dblclick(e, this) : void 0;\n    }\n    clickedKey = $(e.target).hasClass('treema-key');\n    if (!clickedKey) {\n      return typeof (_base1 = this.callbacks).dblclick === \"function\" ? _base1.dblclick(e, this) : void 0;\n    }\n    if (this.isClosed()) {\n      this.open();\n    }\n    this.addNewChild();\n    return typeof (_base2 = this.callbacks).dblclick === \"function\" ? _base2.dblclick(e, this) : void 0;\n  };\n\n  TreemaNode.prototype.onKeyDown = function(e) {\n    var _ref;\n    if (e.which === 27) {\n      this.onEscapePressed(e);\n    }\n    if (e.which === 9) {\n      this.onTabPressed(e);\n    }\n    if (e.which === 37) {\n      this.onLeftArrowPressed(e);\n    }\n    if (e.which === 38) {\n      this.onUpArrowPressed(e);\n    }\n    if (e.which === 39) {\n      this.onRightArrowPressed(e);\n    }\n    if (e.which === 40) {\n      this.onDownArrowPressed(e);\n    }\n    if (e.which === 13) {\n      this.onEnterPressed(e);\n    }\n    if (e.which === 78) {\n      this.onNPressed(e);\n    }\n    if (e.which === 32) {\n      this.onSpacePressed(e);\n    }\n    if (e.which === 84) {\n      this.onTPressed(e);\n    }\n    if (e.which === 70) {\n      this.onFPressed(e);\n    }\n    if (e.which === 90) {\n      this.onZPressed(e);\n    }\n    if (((_ref = e.which) === 8 || _ref === 46) && !e.heldDown) {\n      return this.onDeletePressed(e);\n    }\n  };\n\n  TreemaNode.prototype.onLeftArrowPressed = function(e) {\n    if (this.inputFocused()) {\n      return;\n    }\n    this.navigateOut();\n    return e.preventDefault();\n  };\n\n  TreemaNode.prototype.onRightArrowPressed = function(e) {\n    if (this.inputFocused()) {\n      return;\n    }\n    this.navigateIn();\n    return e.preventDefault();\n  };\n\n  TreemaNode.prototype.onUpArrowPressed = function(e) {\n    if (this.inputFocused()) {\n      return;\n    }\n    this.navigateSelection(-1);\n    return e.preventDefault();\n  };\n\n  TreemaNode.prototype.onDownArrowPressed = function(e) {\n    if (this.inputFocused()) {\n      return;\n    }\n    this.navigateSelection(1);\n    return e.preventDefault();\n  };\n\n  TreemaNode.prototype.inputFocused = function() {\n    var _ref;\n    if (((_ref = document.activeElement.nodeName) === 'INPUT' || _ref === 'TEXTAREA' || _ref === 'SELECT') && !$(document.activeElement).hasClass('treema-clipboard')) {\n      return true;\n    }\n  };\n\n  TreemaNode.prototype.onSpacePressed = function() {};\n\n  TreemaNode.prototype.onTPressed = function() {};\n\n  TreemaNode.prototype.onFPressed = function() {};\n\n  TreemaNode.prototype.onDeletePressed = function(e) {\n    var editing;\n    editing = this.editingIsHappening();\n    if (editing && !$(e.target).val() && this.removeOnEmptyDelete) {\n      this.display();\n      this.select();\n      this.removeSelectedNodes();\n      e.preventDefault();\n    }\n    if (editing) {\n      return;\n    }\n    e.preventDefault();\n    return this.removeSelectedNodes();\n  };\n\n  TreemaNode.prototype.onEscapePressed = function() {\n    if (!this.isEditing()) {\n      return;\n    }\n    if (this.parent && (!this.integrated) && this.defaultData === void 0) {\n      return this.remove();\n    }\n    if (this.isEditing()) {\n      this.display();\n    }\n    if (!this.isRoot()) {\n      this.select();\n    }\n    return this.keepFocus();\n  };\n\n  TreemaNode.prototype.onEnterPressed = function(e) {\n    var offset;\n    offset = e.shiftKey ? -1 : 1;\n    if (offset === 1 && $(e.target).hasClass('treema-add-child')) {\n      return this.addNewChild();\n    }\n    return this.traverseWhileEditing(offset, true);\n  };\n\n  TreemaNode.prototype.onTabPressed = function(e) {\n    var offset;\n    offset = e.shiftKey ? -1 : 1;\n    if (this.hasMoreInputs(offset)) {\n      return;\n    }\n    e.preventDefault();\n    return this.traverseWhileEditing(offset, false);\n  };\n\n  TreemaNode.prototype.hasMoreInputs = function(offset) {\n    var input, inputs, passedFocusedEl, _i, _len;\n    inputs = this.getInputs().toArray();\n    if (offset < 0) {\n      inputs = inputs.reverse();\n    }\n    passedFocusedEl = false;\n    for (_i = 0, _len = inputs.length; _i < _len; _i++) {\n      input = inputs[_i];\n      if (input === document.activeElement) {\n        passedFocusedEl = true;\n        continue;\n      }\n      if (!passedFocusedEl) {\n        continue;\n      }\n      return true;\n    }\n    return false;\n  };\n\n  TreemaNode.prototype.onNPressed = function(e) {\n    var selected, success, target;\n    if (this.editingIsHappening()) {\n      return;\n    }\n    selected = this.getLastSelectedTreema();\n    target = (selected != null ? selected.collection : void 0) ? selected : selected != null ? selected.parent : void 0;\n    if (!target) {\n      return;\n    }\n    success = target.addNewChild();\n    if (success) {\n      this.deselectAll();\n    }\n    return e.preventDefault();\n  };\n\n  TreemaNode.prototype.onZPressed = function(e) {\n    if (e.ctrlKey || e.metaKey) {\n      if (e.shiftKey) {\n        return this.getRoot().redo();\n      } else {\n        return this.getRoot().undo();\n      }\n    }\n  };\n\n  TreemaNode.prototype.traverseWhileEditing = function(offset, aggressive) {\n    var ctx, editing, selected, shouldRemove, targetEl, _ref;\n    shouldRemove = false;\n    selected = this.getLastSelectedTreema();\n    editing = this.isEditing();\n    if (!editing && (selected != null ? selected.canEdit() : void 0)) {\n      return selected.edit();\n    }\n    if (editing) {\n      shouldRemove = this.shouldTryToRemoveFromParent();\n      this.saveChanges(this.getValEl());\n      if (!shouldRemove) {\n        this.flushChanges();\n      }\n      if (!(aggressive || this.isValid())) {\n        this.refreshErrors();\n        return;\n      }\n      if (shouldRemove && ((_ref = $(this.$el[0].nextSibling)) != null ? _ref.hasClass('treema-add-child') : void 0) && offset === 1) {\n        offset = 2;\n      }\n      this.endExistingEdits();\n      this.select();\n    }\n    ctx = this.traversalContext(offset);\n    if (!(ctx != null ? ctx.origin : void 0)) {\n      return;\n    }\n    selected = $(ctx.origin).data('instance');\n    if (offset > 0 && aggressive && selected && selected.collection && selected.isClosed()) {\n      return selected.open();\n    }\n    targetEl = offset > 0 ? ctx.next : ctx.prev;\n    if (!targetEl) {\n      targetEl = offset > 0 ? ctx.first : ctx.last;\n    }\n    this.selectOrActivateElement(targetEl);\n    if (shouldRemove) {\n      return this.remove();\n    } else {\n      return this.refreshErrors();\n    }\n  };\n\n  TreemaNode.prototype.selectOrActivateElement = function(el) {\n    var treema;\n    el = $(el);\n    treema = el.data('instance');\n    if (treema) {\n      if (treema.canEdit()) {\n        return treema.edit();\n      } else {\n        return treema.select();\n      }\n    }\n    this.deselectAll();\n    return el.focus();\n  };\n\n  TreemaNode.prototype.navigateSelection = function(offset) {\n    var ctx, targetTreema;\n    ctx = this.navigationContext();\n    if (!ctx) {\n      return;\n    }\n    if (!ctx.origin) {\n      targetTreema = offset > 0 ? ctx.first : ctx.last;\n      return targetTreema.select();\n    }\n    targetTreema = offset > 0 ? ctx.next : ctx.prev;\n    if (!targetTreema) {\n      targetTreema = offset > 0 ? ctx.first : ctx.last;\n    }\n    return targetTreema != null ? targetTreema.select() : void 0;\n  };\n\n  TreemaNode.prototype.navigateOut = function() {\n    var selected;\n    selected = this.getLastSelectedTreema();\n    if (!selected) {\n      return;\n    }\n    if (selected.isOpen()) {\n      return selected.close();\n    }\n    if ((!selected.parent) || selected.parent.isRoot()) {\n      return;\n    }\n    return selected.parent.select();\n  };\n\n  TreemaNode.prototype.navigateIn = function() {\n    var treema, _i, _len, _ref, _results;\n    _ref = this.getSelectedTreemas();\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      treema = _ref[_i];\n      if (!treema.collection) {\n        continue;\n      }\n      if (treema.isClosed()) {\n        _results.push(treema.open());\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.traversalContext = function(offset) {\n    var list, origin, _ref;\n    list = this.getNavigableElements(offset);\n    origin = (_ref = this.getLastSelectedTreema()) != null ? _ref.$el[0] : void 0;\n    if (!origin) {\n      origin = this.getRootEl().find('.treema-add-child:focus')[0];\n    }\n    if (!origin) {\n      origin = this.getRootEl().find('.treema-new-prop')[0];\n    }\n    return this.wrapContext(list, origin, offset);\n  };\n\n  TreemaNode.prototype.navigationContext = function() {\n    var list, origin;\n    list = this.getFilterVisibleTreemas();\n    origin = this.getLastSelectedTreema();\n    return this.wrapContext(list, origin);\n  };\n\n  TreemaNode.prototype.wrapContext = function(list, origin, offset) {\n    var c, originIndex;\n    if (offset == null) {\n      offset = 1;\n    }\n    if (!list.length) {\n      return;\n    }\n    c = {\n      first: list[0],\n      last: list[list.length - 1],\n      origin: origin\n    };\n    if (origin) {\n      offset = Math.abs(offset);\n      originIndex = list.indexOf(origin);\n      c.next = list[originIndex + offset];\n      c.prev = list[originIndex - offset];\n    }\n    return c;\n  };\n\n  TreemaNode.prototype.canEdit = function() {\n    var _ref;\n    if (this.workingSchema.readOnly || ((_ref = this.parent) != null ? _ref.schema.readOnly : void 0)) {\n      return false;\n    }\n    if (this.settings.readOnly) {\n      return false;\n    }\n    if (!this.editable) {\n      return false;\n    }\n    if (!this.directlyEditable) {\n      return false;\n    }\n    if (this.collection && this.isOpen()) {\n      return false;\n    }\n    return true;\n  };\n\n  TreemaNode.prototype.display = function() {\n    return this.toggleEdit('treema-display');\n  };\n\n  TreemaNode.prototype.edit = function(options) {\n    if (options == null) {\n      options = {};\n    }\n    this.toggleEdit('treema-edit');\n    if ((options.offset != null) && options.offset < 0) {\n      return this.focusLastInput();\n    }\n  };\n\n  TreemaNode.prototype.toggleEdit = function(toClass) {\n    var valEl;\n    if (toClass == null) {\n      toClass = null;\n    }\n    if (!this.editable) {\n      return;\n    }\n    valEl = this.getValEl();\n    if (toClass && valEl.hasClass(toClass)) {\n      return;\n    }\n    toClass = toClass || (valEl.hasClass('treema-display') ? 'treema-edit' : 'treema-display');\n    if (toClass === 'treema-edit') {\n      this.endExistingEdits();\n    }\n    valEl.removeClass('treema-display').removeClass('treema-edit').addClass(toClass);\n    valEl.empty();\n    if (this.isDisplaying()) {\n      this.buildValueForDisplay(valEl, this.getData());\n    }\n    if (this.isEditing()) {\n      this.buildValueForEditing(valEl, this.getData());\n      return this.deselectAll();\n    }\n  };\n\n  TreemaNode.prototype.endExistingEdits = function() {\n    var editing, elem, treema, _i, _len, _results;\n    editing = this.getRootEl().find('.treema-edit').closest('.treema-node');\n    _results = [];\n    for (_i = 0, _len = editing.length; _i < _len; _i++) {\n      elem = editing[_i];\n      treema = $(elem).data('instance');\n      treema.saveChanges(treema.getValEl());\n      treema.display();\n      _results.push(this.markAsChanged());\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.flushChanges = function() {\n    var parent, _results;\n    if (this.parent && (!this.integrated) && this.data !== void 0) {\n      this.parent.integrateChildTreema(this);\n    }\n    this.getRoot().cachedErrors = null;\n    this.markAsChanged();\n    if (!this.parent) {\n      return this.refreshErrors();\n    }\n    this.updateDefaultClass();\n    if (this.data !== void 0) {\n      this.parent.data[this.keyForParent] = this.data;\n    }\n    this.parent.refreshErrors();\n    parent = this.parent;\n    _results = [];\n    while (parent) {\n      parent.buildValueForDisplay(parent.getValEl().empty(), parent.getData());\n      _results.push(parent = parent.parent);\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.focusLastInput = function() {\n    var inputs, last;\n    inputs = this.getInputs();\n    last = inputs[inputs.length - 1];\n    return $(last).focus().select();\n  };\n\n  TreemaNode.prototype.removeSelectedNodes = function(nodes) {\n    var data, nextSibling, parentPaths, paths, prevSibling, selected, toSelect, treema, _i, _j, _len, _len1, _ref;\n    if (nodes == null) {\n      nodes = [];\n    }\n    selected = nodes;\n    if (!nodes.length) {\n      selected = this.getSelectedTreemas();\n    }\n    toSelect = null;\n    if (selected.length === 1) {\n      nextSibling = selected[0].$el.next('.treema-node').data('instance');\n      prevSibling = selected[0].$el.prev('.treema-node').data('instance');\n      toSelect = nextSibling || prevSibling || selected[0].parent;\n    }\n    data = [];\n    paths = [];\n    parentPaths = [];\n    this.getRoot().hush = true;\n    for (_i = 0, _len = selected.length; _i < _len; _i++) {\n      treema = selected[_i];\n      data.push(treema.data);\n      paths.push(treema.getPath());\n      parentPaths.push((_ref = treema.parent) != null ? _ref.getPath() : void 0);\n    }\n    this.addTrackedAction({\n      'data': data,\n      'path': paths,\n      'parentPath': parentPaths,\n      'action': 'delete'\n    });\n    for (_j = 0, _len1 = selected.length; _j < _len1; _j++) {\n      treema = selected[_j];\n      treema.remove();\n    }\n    if (toSelect && !this.getSelectedTreemas().length) {\n      toSelect.select();\n    }\n    this.getRoot().hush = false;\n    return this.broadcastChanges();\n  };\n\n  TreemaNode.prototype.remove = function() {\n    var newNode, options, readOnly, required, tempError, _ref, _ref1;\n    required = this.parent && (this.parent.schema.required != null) && (_ref = this.keyForParent, __indexOf.call(this.parent.schema.required, _ref) >= 0);\n    if (required) {\n      tempError = this.createTemporaryError('required');\n      this.$el.prepend(tempError);\n      return false;\n    }\n    readOnly = this.workingSchema.readOnly || ((_ref1 = this.parent) != null ? _ref1.schema.readOnly : void 0);\n    if (readOnly) {\n      tempError = this.createTemporaryError('read only');\n      this.$el.prepend(tempError);\n      return false;\n    }\n    if (this.defaultData !== void 0) {\n      options = $.extend({}, this.settings, {\n        defaultData: this.defaultData,\n        schema: this.workingSchema\n      });\n      newNode = TreemaNode.make(null, options, this.parent, this.keyForParent);\n      if (this.parent) {\n        this.parent.segregateChildTreema(this);\n      }\n      this.replaceNode(newNode);\n      this.destroy();\n      return true;\n    }\n    this.$el.remove();\n    if (document.activeElement === $('body')[0]) {\n      this.keepFocus();\n    }\n    if (this.parent) {\n      this.parent.segregateChildTreema(this);\n    }\n    this.destroy();\n    return true;\n  };\n\n  TreemaNode.prototype.updateDefaultClass = function() {\n    var child, key, _ref, _results;\n    this.$el.removeClass('treema-default-stub');\n    if (this.isDefaultStub() && !this.parent.isDefaultStub()) {\n      this.$el.addClass('treema-default-stub');\n    }\n    _ref = this.childrenTreemas;\n    _results = [];\n    for (key in _ref) {\n      child = _ref[key];\n      _results.push(child.updateDefaultClass());\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.toggleOpen = function() {\n    if (this.isClosed()) {\n      this.open();\n    } else {\n      this.close();\n    }\n    return this;\n  };\n\n  TreemaNode.prototype.open = function(depth) {\n    var child, childIndex, childNode, childrenContainer, treema, _i, _len, _ref, _ref1, _ref2, _results;\n    if (depth == null) {\n      depth = 1;\n    }\n    if (this.isClosed()) {\n      childrenContainer = this.$el.find('.treema-children').detach();\n      childrenContainer.empty();\n      this.childrenTreemas = {};\n      _ref = this.getChildren();\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        child = _ref[_i];\n        if (child.schema.format === 'hidden') {\n          continue;\n        }\n        treema = TreemaNode.make(null, {\n          schema: child.schema,\n          data: child.value,\n          defaultData: child.defaultData\n        }, this, child.key);\n        if (!(treema.data === void 0 || (this.data === void 0 && !this.integrated))) {\n          this.integrateChildTreema(treema);\n        }\n        this.childrenTreemas[treema.keyForParent] = treema;\n        childNode = this.createChildNode(treema);\n        childrenContainer.append(childNode);\n      }\n      this.$el.append(childrenContainer).removeClass('treema-closed').addClass('treema-open');\n      childrenContainer.append($(this.addChildTemplate));\n      if (this.ordered && childrenContainer.sortable && !this.settings.noSortable) {\n        if (typeof childrenContainer.sortable === \"function\") {\n          childrenContainer.sortable({\n            deactivate: this.orderDataFromUI,\n            forcePlaceholderSize: true,\n            placeholder: 'placeholder'\n          });\n        }\n      }\n      this.refreshErrors();\n    }\n    depth -= 1;\n    if (depth) {\n      _ref2 = (_ref1 = this.childrenTreemas) != null ? _ref1 : {};\n      _results = [];\n      for (childIndex in _ref2) {\n        child = _ref2[childIndex];\n        _results.push(child.open(depth));\n      }\n      return _results;\n    }\n  };\n\n  TreemaNode.prototype.orderDataFromUI = function() {\n    var child, children, index, treema, _i, _len;\n    children = this.$el.find('> .treema-children > .treema-node');\n    index = 0;\n    this.childrenTreemas = {};\n    this.data = $.isArray(this.data) ? [] : {};\n    for (_i = 0, _len = children.length; _i < _len; _i++) {\n      child = children[_i];\n      treema = $(child).data('instance');\n      if (!(treema != null ? treema.data : void 0)) {\n        continue;\n      }\n      if ($.isArray(this.data)) {\n        treema.keyForParent = index;\n        this.childrenTreemas[index] = treema;\n        this.data[index] = treema.data;\n      } else {\n        this.childrenTreemas[treema.keyForParent] = treema;\n        this.data[treema.keyForParent] = treema.data;\n      }\n      index += 1;\n    }\n    this.flushChanges();\n    return this.broadcastChanges();\n  };\n\n  TreemaNode.prototype.close = function(saveChildData) {\n    var child, key, treema, _ref;\n    if (saveChildData == null) {\n      saveChildData = true;\n    }\n    if (!this.isOpen()) {\n      return;\n    }\n    if (saveChildData) {\n      _ref = this.childrenTreemas;\n      for (key in _ref) {\n        treema = _ref[key];\n        if (treema.integrated) {\n          this.data[key] = treema.data;\n        }\n      }\n    }\n    this.$el.find('.treema-children').empty();\n    this.$el.addClass('treema-closed').removeClass('treema-open');\n    for (child in this.childrenTreemas) {\n      this.childrenTreemas[child].destroy();\n    }\n    this.childrenTreemas = null;\n    this.refreshErrors();\n    return this.buildValueForDisplay(this.getValEl().empty(), this.getData());\n  };\n\n  TreemaNode.prototype.select = function() {\n    var excludeSelf, numSelected;\n    numSelected = this.getSelectedTreemas().length;\n    excludeSelf = numSelected === 1;\n    this.deselectAll(excludeSelf);\n    this.toggleSelect();\n    this.keepFocus();\n    TreemaNode.didSelect = true;\n    return TreemaNode.lastTreemaWithFocus = this.getRoot();\n  };\n\n  TreemaNode.prototype.deselectAll = function(excludeSelf) {\n    var treema, _i, _len, _ref;\n    if (excludeSelf == null) {\n      excludeSelf = false;\n    }\n    _ref = this.getSelectedTreemas();\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      treema = _ref[_i];\n      if (excludeSelf && treema === this) {\n        continue;\n      }\n      treema.$el.removeClass('treema-selected');\n    }\n    this.clearLastSelected();\n    return TreemaNode.didSelect = true;\n  };\n\n  TreemaNode.prototype.toggleSelect = function() {\n    this.clearLastSelected();\n    if (!this.isRoot()) {\n      this.$el.toggleClass('treema-selected');\n    }\n    if (this.isSelected()) {\n      this.setLastSelectedTreema(this);\n    }\n    return TreemaNode.didSelect = true;\n  };\n\n  TreemaNode.prototype.clearLastSelected = function() {\n    var _ref;\n    if ((_ref = this.getLastSelectedTreema()) != null) {\n      _ref.$el.removeClass('treema-last-selected');\n    }\n    return this.setLastSelectedTreema(null);\n  };\n\n  TreemaNode.prototype.shiftSelect = function() {\n    var allNodes, endNodes, lastSelected, node, started, _i, _len;\n    lastSelected = this.getRootEl().find('.treema-last-selected');\n    this.select();\n    if (!lastSelected.length) {\n      return;\n    }\n    this.deselectAll();\n    allNodes = this.getRootEl().find('.treema-node');\n    endNodes = [this, lastSelected.data('instance')];\n    started = false;\n    for (_i = 0, _len = allNodes.length; _i < _len; _i++) {\n      node = allNodes[_i];\n      node = $(node).data('instance');\n      if (!started) {\n        if (__indexOf.call(endNodes, node) >= 0) {\n          node.$el.addClass('treema-selected');\n          started = true;\n        }\n        continue;\n      }\n      node.$el.addClass('treema-selected');\n      if (started && (__indexOf.call(endNodes, node) >= 0)) {\n        break;\n      }\n    }\n    lastSelected.removeClass('treema-last-selected');\n    this.$el.addClass('treema-last-selected');\n    return TreemaNode.didSelect = true;\n  };\n\n  TreemaNode.prototype.addTrackedAction = function(action) {\n    var root;\n    root = this.getRoot();\n    if (root.trackingDisabled) {\n      return;\n    }\n    root.trackedActions.splice(root.currentStateIndex, root.trackedActions.length - root.currentStateIndex);\n    root.trackedActions.push(action);\n    return root.currentStateIndex++;\n  };\n\n  TreemaNode.prototype.disableTracking = function() {\n    return this.getRoot().trackingDisabled = true;\n  };\n\n  TreemaNode.prototype.enableTracking = function() {\n    return this.getRoot().trackingDisabled = false;\n  };\n\n  TreemaNode.prototype.canUndo = function() {\n    return this.getCurrentStateIndex() !== 0;\n  };\n\n  TreemaNode.prototype.undo = function() {\n    var currentStateIndex, deleteIndex, i, parentData, parentPath, restoreChange, root, trackedActions, treemaData, treemaPath, _i, _len, _ref;\n    if (!this.canUndo()) {\n      return;\n    }\n    trackedActions = this.getTrackedActions();\n    currentStateIndex = this.getCurrentStateIndex();\n    root = this.getRoot();\n    this.disableTracking();\n    restoreChange = trackedActions[currentStateIndex - 1];\n    switch (restoreChange.action) {\n      case 'delete':\n        if (!$.isArray(restoreChange.path)) {\n          restoreChange.data = [restoreChange.data];\n          restoreChange.path = [restoreChange.path];\n          restoreChange.parentPath = [restoreChange.parentPath];\n        }\n        _ref = restoreChange.data;\n        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n          treemaData = _ref[i];\n          parentPath = restoreChange.parentPath[i];\n          treemaPath = restoreChange.path[i];\n          parentData = this.get(parentPath);\n          switch ($.isArray(parentData)) {\n            case false:\n              this.set(treemaPath, treemaData);\n              break;\n            case true:\n              deleteIndex = parseInt(treemaPath.substring(treemaPath.lastIndexOf('/') + 1));\n              if (deleteIndex < parentData.length) {\n                parentData.splice(deleteIndex, 0, treemaData);\n                this.set(parentPath, parentData);\n              } else {\n                this.insert(parentPath, treemaData);\n              }\n          }\n        }\n        break;\n      case 'edit':\n        if (restoreChange.oldData === void 0) {\n          this[\"delete\"](restoreChange.path);\n        } else {\n          this.set(restoreChange.path, restoreChange.oldData);\n        }\n        break;\n      case 'replace':\n        restoreChange.newNode.replaceNode(restoreChange.oldNode);\n        this.set(restoreChange.path, restoreChange.oldNode.data);\n        break;\n      case 'insert':\n        this[\"delete\"](restoreChange.path);\n    }\n    root.currentStateIndex--;\n    return this.enableTracking();\n  };\n\n  TreemaNode.prototype.canRedo = function() {\n    return this.getCurrentStateIndex() !== this.getTrackedActions().length;\n  };\n\n  TreemaNode.prototype.redo = function() {\n    var currentStateIndex, parentData, path, restoreChange, root, trackedActions, _i, _len, _ref;\n    if (!this.canRedo()) {\n      return;\n    }\n    trackedActions = this.getTrackedActions();\n    currentStateIndex = this.getCurrentStateIndex();\n    root = this.getRoot();\n    this.disableTracking();\n    restoreChange = trackedActions[currentStateIndex];\n    switch (restoreChange.action) {\n      case 'delete':\n        if (!$.isArray(restoreChange.path)) {\n          restoreChange.path = [restoreChange.path];\n        }\n        _ref = restoreChange.path;\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          path = _ref[_i];\n          this[\"delete\"](path);\n        }\n        break;\n      case 'edit':\n        this.set(restoreChange.path, restoreChange.newData);\n        break;\n      case 'replace':\n        restoreChange.oldNode.replaceNode(restoreChange.newNode);\n        this.set(restoreChange.path, restoreChange.newNode.data);\n        break;\n      case 'insert':\n        parentData = this.get(restoreChange.parentPath);\n        switch ($.isArray(parentData)) {\n          case true:\n            this.insert(restoreChange.parentPath, restoreChange.data);\n            break;\n          case false:\n            this.set(restoreChange.path, restoreChange.data);\n        }\n    }\n    root.currentStateIndex++;\n    return this.enableTracking();\n  };\n\n  TreemaNode.prototype.getUndoDescription = function() {\n    var currentStateIndex, trackedActions;\n    if (!this.canUndo()) {\n      return '';\n    }\n    trackedActions = this.getTrackedActions();\n    currentStateIndex = this.getCurrentStateIndex();\n    return this.getTrackedActionDescription(trackedActions[currentStateIndex - 1]);\n  };\n\n  TreemaNode.prototype.getRedoDescription = function() {\n    var currentStateIndex, trackedActions;\n    if (!this.canRedo()) {\n      return '';\n    }\n    trackedActions = this.getTrackedActions();\n    currentStateIndex = this.getCurrentStateIndex();\n    return this.getTrackedActionDescription(trackedActions[currentStateIndex]);\n  };\n\n  TreemaNode.prototype.getTrackedActionDescription = function(trackedAction) {\n    var path, trackedActionDescription;\n    switch (trackedAction.action) {\n      case 'insert':\n        trackedActionDescription = 'Add New ' + this.nodeDescription;\n        break;\n      case 'delete':\n        trackedActionDescription = 'Delete ' + this.nodeDescription;\n        break;\n      case 'edit':\n        path = trackedAction.path.split('/');\n        if (path[path.length - 1] === 'pos') {\n          trackedActionDescription = 'Move ' + this.nodeDescription;\n        } else {\n          trackedActionDescription = 'Edit ' + this.nodeDescription;\n        }\n        break;\n      default:\n        trackedActionDescription = '';\n    }\n    return trackedActionDescription;\n  };\n\n  TreemaNode.prototype.getTrackedActions = function() {\n    return this.getRoot().trackedActions;\n  };\n\n  TreemaNode.prototype.getCurrentStateIndex = function() {\n    return this.getRoot().currentStateIndex;\n  };\n\n  TreemaNode.prototype.onSelectSchema = function(e) {\n    var index, newNode, settings, workingSchema;\n    index = parseInt($(e.target).val());\n    workingSchema = this.workingSchemas[index];\n    settings = $.extend(true, {}, this.settings);\n    settings = $.extend(settings, {\n      workingSchemas: this.workingSchemas,\n      workingSchema: workingSchema,\n      data: this.data,\n      defaultData: this.defaultData,\n      schema: this.schema\n    });\n    newNode = TreemaNode.make(null, settings, this.parent, this.keyForParent);\n    return this.replaceNode(newNode);\n  };\n\n  TreemaNode.prototype.onSelectType = function(e) {\n    var newNode, newType, settings;\n    newType = $(e.target).val();\n    settings = $.extend(true, {}, this.settings, {\n      workingSchemas: this.workingSchemas,\n      workingSchema: this.workingSchema,\n      type: newType,\n      data: this.data,\n      defaultData: this.defaultData,\n      schema: this.schema\n    });\n    if ($.type(this.data) !== newType) {\n      settings.data = TreemaNode.defaultForType(newType);\n    }\n    newNode = TreemaNode.make(null, settings, this.parent, this.keyForParent);\n    return this.replaceNode(newNode);\n  };\n\n  TreemaNode.prototype.replaceNode = function(newNode) {\n    newNode.tv4 = this.tv4;\n    if (this.keyForParent != null) {\n      newNode.keyForParent = this.keyForParent;\n    }\n    if (this.parent) {\n      this.parent.childrenTreemas[this.keyForParent] = newNode;\n    }\n    this.parent.createChildNode(newNode);\n    this.$el.replaceWith(newNode.$el);\n    newNode.flushChanges();\n    return this.addTrackedAction({\n      'oldNode': this,\n      'newNode': newNode,\n      'path': this.getPath(),\n      'action': 'replace'\n    });\n  };\n\n  TreemaNode.prototype.integrateChildTreema = function(treema) {\n    var newData;\n    if (this.parent && !this.integrated) {\n      this.data = $.isArray(this.defaultData) ? [] : {};\n      this.parent.integrateChildTreema(this);\n    } else {\n      treema.updateDefaultClass();\n    }\n    newData = this.data[treema.keyForParent] !== treema.data;\n    treema.integrated = true;\n    this.childrenTreemas[treema.keyForParent] = treema;\n    this.data[treema.keyForParent] = treema.data;\n    if (newData) {\n      if (this.ordered) {\n        this.orderDataFromUI();\n      }\n      this.refreshErrors();\n      this.updateMyAddButton();\n      this.markAsChanged();\n      this.buildValueForDisplay(this.getValEl().empty(), this.getData());\n      this.broadcastChanges();\n    }\n    return treema;\n  };\n\n  TreemaNode.prototype.segregateChildTreema = function(treema) {\n    treema.integrated = false;\n    delete this.childrenTreemas[treema.keyForParent];\n    delete this.data[treema.keyForParent];\n    if (this.ordered) {\n      this.orderDataFromUI();\n    }\n    this.refreshErrors();\n    this.updateMyAddButton();\n    this.markAsChanged();\n    this.buildValueForDisplay(this.getValEl().empty(), this.getData());\n    this.broadcastChanges();\n    return treema;\n  };\n\n  TreemaNode.prototype.createChildNode = function(treema) {\n    var childNode, defnEl, keyEl, name, required, row, suffix, _ref;\n    childNode = treema.build();\n    row = childNode.find('.treema-row');\n    if (this.collection && this.keyed) {\n      name = treema.schema.title || treema.keyForParent;\n      required = this.workingSchema.required || [];\n      suffix = ': ';\n      if (_ref = treema.keyForParent, __indexOf.call(required, _ref) >= 0) {\n        suffix = '*' + suffix;\n      }\n      keyEl = $(this.keyTemplate).text(name + suffix);\n      row.prepend(keyEl);\n      defnEl = $('<span></span>').addClass('treema-description').text(treema.schema.description || '');\n      row.append(defnEl);\n    }\n    if (treema.collection) {\n      childNode.prepend($(this.toggleTemplate));\n    }\n    return childNode;\n  };\n\n  TreemaNode.prototype.refreshErrors = function() {\n    this.clearErrors();\n    return this.showErrors();\n  };\n\n  TreemaNode.prototype.showErrors = function() {\n    var childErrors, deepestTreema, e, error, erroredTreemas, errors, message, messages, ownErrors, path, subpath, treema, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;\n    if (this.parent && !this.integrated) {\n      return;\n    }\n    if (this.settings.skipValidation) {\n      return;\n    }\n    errors = this.getErrors();\n    erroredTreemas = [];\n    for (_i = 0, _len = errors.length; _i < _len; _i++) {\n      error = errors[_i];\n      path = ((_ref = error.subDataPath) != null ? _ref : error.dataPath).slice(1);\n      path = path ? path.split('/') : [];\n      deepestTreema = this;\n      for (_j = 0, _len1 = path.length; _j < _len1; _j++) {\n        subpath = path[_j];\n        if (!deepestTreema.childrenTreemas) {\n          error.forChild = true;\n          break;\n        }\n        if (deepestTreema.ordered) {\n          subpath = parseInt(subpath);\n        }\n        deepestTreema = deepestTreema.childrenTreemas[subpath];\n        if (!deepestTreema) {\n          console.error('could not find treema down path', path, this, \"so couldn't show error\", error);\n          return;\n        }\n      }\n      if (!(deepestTreema._errors && __indexOf.call(erroredTreemas, deepestTreema) >= 0)) {\n        deepestTreema._errors = [];\n      }\n      deepestTreema._errors.push(error);\n      erroredTreemas.push(deepestTreema);\n    }\n    _ref1 = $.unique(erroredTreemas);\n    _results = [];\n    for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n      treema = _ref1[_k];\n      childErrors = (function() {\n        var _l, _len3, _ref2, _results1;\n        _ref2 = treema._errors;\n        _results1 = [];\n        for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {\n          e = _ref2[_l];\n          if (e.forChild) {\n            _results1.push(e);\n          }\n        }\n        return _results1;\n      })();\n      ownErrors = (function() {\n        var _l, _len3, _ref2, _results1;\n        _ref2 = treema._errors;\n        _results1 = [];\n        for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {\n          e = _ref2[_l];\n          if (!e.forChild) {\n            _results1.push(e);\n          }\n        }\n        return _results1;\n      })();\n      messages = (function() {\n        var _l, _len3, _results1;\n        _results1 = [];\n        for (_l = 0, _len3 = ownErrors.length; _l < _len3; _l++) {\n          e = ownErrors[_l];\n          _results1.push(e.message);\n        }\n        return _results1;\n      })();\n      if (childErrors.length > 0) {\n        message = \"[\" + childErrors.length + \"] error\";\n        if (childErrors.length > 1) {\n          message = message + 's';\n        }\n        messages.push(message);\n      }\n      _results.push(treema.showError(messages.join('<br />')));\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.showError = function(message) {\n    this.$el.prepend($(this.errorTemplate));\n    this.$el.find('> .treema-error').html(message).show();\n    return this.$el.addClass('treema-has-error');\n  };\n\n  TreemaNode.prototype.clearErrors = function() {\n    this.$el.find('.treema-error').remove();\n    this.$el.find('.treema-has-error').removeClass('treema-has-error');\n    return this.$el.removeClass('treema-has-error');\n  };\n\n  TreemaNode.prototype.createTemporaryError = function(message, attachFunction) {\n    if (attachFunction == null) {\n      attachFunction = null;\n    }\n    if (!attachFunction) {\n      attachFunction = this.$el.prepend;\n    }\n    this.clearTemporaryErrors();\n    return $(this.tempErrorTemplate).text(message).delay(3000).fadeOut(1000, function() {\n      return $(this).remove();\n    });\n  };\n\n  TreemaNode.prototype.clearTemporaryErrors = function() {\n    return this.getRootEl().find('.treema-temp-error').remove();\n  };\n\n  TreemaNode.prototype.get = function(path) {\n    var data, seg, _i, _len;\n    if (path == null) {\n      path = '/';\n    }\n    path = this.normalizePath(path);\n    if (path.length === 0) {\n      return this.data;\n    }\n    if (this.childrenTreemas != null) {\n      return this.digDeeper(path, 'get', void 0, []);\n    }\n    data = this.data;\n    for (_i = 0, _len = path.length; _i < _len; _i++) {\n      seg = path[_i];\n      data = data[this.normalizeKey(seg, data)];\n      if (data === void 0) {\n        break;\n      }\n    }\n    return data;\n  };\n\n  TreemaNode.prototype.set = function(path, newData) {\n    var oldData;\n    oldData = this.get(path);\n    if (this.setRecursive(path, newData)) {\n      if (JSON.stringify(newData) !== JSON.stringify(oldData)) {\n        this.addTrackedAction({\n          'oldData': oldData,\n          'newData': newData,\n          'path': path,\n          'action': 'edit'\n        });\n      }\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  TreemaNode.prototype.setRecursive = function(path, newData) {\n    var data, i, nodePath, oldData, result, seg, _i, _len;\n    path = this.normalizePath(path);\n    if (path.length === 0) {\n      this.data = newData;\n      this.refreshDisplay();\n      return true;\n    }\n    if (this.childrenTreemas != null) {\n      result = this.digDeeper(path, 'setRecursive', false, [newData]);\n      if (result === false && path.length === 1 && $.isPlainObject(this.data)) {\n        this.data[path[0]] = newData;\n        this.refreshDisplay();\n        return true;\n      }\n      return result;\n    }\n    data = this.data;\n    nodePath = this.getPath();\n    for (i = _i = 0, _len = path.length; _i < _len; i = ++_i) {\n      seg = path[i];\n      seg = this.normalizeKey(seg, data);\n      if (path.length === i + 1) {\n        oldData = data[seg];\n        data[seg] = newData;\n        this.refreshDisplay();\n        return true;\n      } else {\n        data = data[seg];\n        if (data === void 0) {\n          return false;\n        }\n      }\n    }\n  };\n\n  TreemaNode.prototype[\"delete\"] = function(path) {\n    var oldData, parentPath;\n    oldData = this.get(path);\n    if (this.deleteRecursive(path)) {\n      parentPath = path.substring(0, path.lastIndexOf('/'));\n      this.addTrackedAction({\n        'data': oldData,\n        'path': path,\n        'parentPath': parentPath,\n        'action': 'delete'\n      });\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  TreemaNode.prototype.deleteRecursive = function(path) {\n    var data, i, parentPath, seg, _i, _len;\n    path = this.normalizePath(path);\n    if (path.length === 0) {\n      return this.remove();\n    }\n    if (this.childrenTreemas != null) {\n      return this.digDeeper(path, 'deleteRecursive', false, []);\n    }\n    data = this.data;\n    parentPath = this.getPath();\n    for (i = _i = 0, _len = path.length; _i < _len; i = ++_i) {\n      seg = path[i];\n      seg = this.normalizeKey(seg, data);\n      if (path.length === i + 1) {\n        if ($.isArray(data)) {\n          data.splice(seg, 1);\n        } else {\n          delete data[seg];\n        }\n        this.refreshDisplay();\n        return true;\n      } else {\n        data = data[seg];\n        if (data === void 0) {\n          return false;\n        }\n      }\n      parentPath += '/' + seg;\n    }\n  };\n\n  TreemaNode.prototype.insert = function(path, newData) {\n    var childPath, insertPos, key, parentData, parentPath, val;\n    if (this.insertRecursive(path, newData)) {\n      parentPath = path;\n      parentData = this.get(parentPath);\n      childPath = parentPath;\n      if (parentPath !== '/') {\n        childPath += '/';\n      }\n      if (parentData[parentData.length - 1] !== newData) {\n        for (key in parentData) {\n          val = parentData[key];\n          if (JSON.stringify(val) === JSON.stringify(newData)) {\n            insertPos = key;\n            break;\n          }\n        }\n      } else {\n        insertPos = parentData.length - 1;\n      }\n      childPath += insertPos.toString();\n      this.addTrackedAction({\n        'data': newData,\n        'path': childPath,\n        'parentPath': parentPath,\n        'action': 'insert'\n      });\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  TreemaNode.prototype.insertRecursive = function(path, newData) {\n    var data, i, parentPath, seg, _i, _len;\n    path = this.normalizePath(path);\n    if (path.length === 0) {\n      if (!$.isArray(this.data)) {\n        return false;\n      }\n      this.data.push(newData);\n      this.refreshDisplay();\n      this.flushChanges();\n      return true;\n    }\n    if (this.childrenTreemas != null) {\n      return this.digDeeper(path, 'insertRecursive', false, [newData]);\n    }\n    data = this.data;\n    parentPath = this.getPath();\n    for (i = _i = 0, _len = path.length; _i < _len; i = ++_i) {\n      seg = path[i];\n      parentPath += '/' + seg;\n      seg = this.normalizeKey(seg, data);\n      data = data[seg];\n      if (data === void 0) {\n        return false;\n      }\n    }\n    if (!$.isArray(data)) {\n      return false;\n    }\n    data.push(newData);\n    this.refreshDisplay();\n    return true;\n  };\n\n  TreemaNode.prototype.normalizeKey = function(key, collection) {\n    var i, parts, value, _i, _len;\n    if ($.isArray(collection)) {\n      if (__indexOf.call(key, '=') >= 0) {\n        parts = key.split('=');\n        for (i = _i = 0, _len = collection.length; _i < _len; i = ++_i) {\n          value = collection[i];\n          if (value[parts[0]] === parts[1]) {\n            return i;\n          }\n        }\n      } else {\n        return parseInt(key);\n      }\n    }\n    return key;\n  };\n\n  TreemaNode.prototype.normalizePath = function(path) {\n    var s;\n    if ($.type(path) === 'string') {\n      path = path.split('/');\n      path = (function() {\n        var _i, _len, _results;\n        _results = [];\n        for (_i = 0, _len = path.length; _i < _len; _i++) {\n          s = path[_i];\n          if (s.length) {\n            _results.push(s);\n          }\n        }\n        return _results;\n      })();\n    }\n    return path;\n  };\n\n  TreemaNode.prototype.digDeeper = function(path, func, def, args) {\n    var childTreema, seg;\n    seg = this.normalizeKey(path[0], this.data);\n    childTreema = this.childrenTreemas[seg];\n    if (childTreema === void 0 || !childTreema.integrated) {\n      return def;\n    }\n    return childTreema[func].apply(childTreema, [path.slice(1)].concat(__slice.call(args)));\n  };\n\n  TreemaNode.prototype.refreshDisplay = function() {\n    if (this.isDisplaying()) {\n      this.buildValueForDisplay(this.getValEl().empty(), this.getData());\n    } else {\n      this.display();\n    }\n    if (this.collection && this.isOpen()) {\n      this.close(false);\n      this.open();\n    }\n    this.flushChanges();\n    return this.broadcastChanges();\n  };\n\n  TreemaNode.prototype.getNodeEl = function() {\n    return this.$el;\n  };\n\n  TreemaNode.prototype.getValEl = function() {\n    return this.$el.find('> .treema-row .treema-value');\n  };\n\n  TreemaNode.prototype.getRootEl = function() {\n    return this.$el.closest('.treema-root');\n  };\n\n  TreemaNode.prototype.getRoot = function() {\n    var node;\n    node = this;\n    while (node.parent != null) {\n      node = node.parent;\n    }\n    return node;\n  };\n\n  TreemaNode.prototype.getInputs = function() {\n    return this.getValEl().find('input, textarea');\n  };\n\n  TreemaNode.prototype.getSelectedTreemas = function() {\n    var el, _i, _len, _ref, _results;\n    _ref = this.getRootEl().find('.treema-selected');\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      el = _ref[_i];\n      _results.push($(el).data('instance'));\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.getLastSelectedTreema = function() {\n    return this.getRoot().lastSelectedTreema;\n  };\n\n  TreemaNode.prototype.setLastSelectedTreema = function(node) {\n    this.getRoot().lastSelectedTreema = node;\n    return node != null ? node.$el.addClass('treema-last-selected') : void 0;\n  };\n\n  TreemaNode.prototype.getAddButtonEl = function() {\n    return this.$el.find('> .treema-children > .treema-add-child');\n  };\n\n  TreemaNode.prototype.getVisibleTreemas = function() {\n    var el, _i, _len, _ref, _results;\n    _ref = this.getRootEl().find('.treema-node');\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      el = _ref[_i];\n      _results.push($(el).data('instance'));\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.getNavigableElements = function() {\n    return this.getRootEl().find('.treema-node, .treema-add-child:visible').toArray();\n  };\n\n  TreemaNode.prototype.getPath = function() {\n    var pathPieces, pointer;\n    pathPieces = [];\n    pointer = this;\n    while (pointer && (pointer.keyForParent != null)) {\n      pathPieces.push(pointer.keyForParent + '');\n      pointer = pointer.parent;\n    }\n    pathPieces.reverse();\n    return '/' + pathPieces.join('/');\n  };\n\n  TreemaNode.prototype.getData = function() {\n    if ($.type(this.data) === 'undefined') {\n      return this.defaultData;\n    } else {\n      return this.data;\n    }\n  };\n\n  TreemaNode.prototype.isDefaultStub = function() {\n    return this.data === void 0;\n  };\n\n  TreemaNode.getLastTreemaWithFocus = function() {\n    return this.lastTreemaWithFocus;\n  };\n\n  TreemaNode.prototype.isRoot = function() {\n    return !this.parent;\n  };\n\n  TreemaNode.prototype.isEditing = function() {\n    return this.getValEl().hasClass('treema-edit');\n  };\n\n  TreemaNode.prototype.isDisplaying = function() {\n    return this.getValEl().hasClass('treema-display');\n  };\n\n  TreemaNode.prototype.isOpen = function() {\n    return this.$el.hasClass('treema-open');\n  };\n\n  TreemaNode.prototype.isClosed = function() {\n    return this.$el.hasClass('treema-closed');\n  };\n\n  TreemaNode.prototype.isSelected = function() {\n    return this.$el.hasClass('treema-selected');\n  };\n\n  TreemaNode.prototype.wasSelectedLast = function() {\n    return this.$el.hasClass('treema-last-selected');\n  };\n\n  TreemaNode.prototype.editingIsHappening = function() {\n    return this.getRootEl().find('.treema-edit').length;\n  };\n\n  TreemaNode.prototype.rootSelected = function() {\n    return $(document.activeElement).hasClass('treema-root');\n  };\n\n  TreemaNode.prototype.setFilterVisible = function(isFilterVisible) {\n    if (isFilterVisible) {\n      return this.$el.find('.treema-node').andSelf().removeClass(this.treemaFilterHiddenClass);\n    } else {\n      return this.$el.find('.treema-node').andSelf().addClass(this.treemaFilterHiddenClass);\n    }\n  };\n\n  TreemaNode.prototype.getFilterVisibleTreemas = function() {\n    var el, _i, _len, _ref, _results;\n    _ref = this.getRootEl().find('.treema-node').not('.' + this.treemaFilterHiddenClass);\n    _results = [];\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      el = _ref[_i];\n      _results.push($(el).data('instance'));\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.isFilterVisible = function() {\n    return !this.$el.hasClass(this.treemaFilterHiddenClass);\n  };\n\n  TreemaNode.prototype.saveScrolls = function() {\n    var parent, rootEl, _results;\n    this.scrolls = [];\n    rootEl = this.getRootEl();\n    parent = rootEl;\n    _results = [];\n    while (parent[0]) {\n      this.scrolls.push({\n        el: parent,\n        scrollTop: parent.scrollTop(),\n        scrollLeft: parent.scrollLeft()\n      });\n      if (parent.prop('tagName').toLowerCase() === 'body') {\n        break;\n      }\n      _results.push(parent = parent.parent());\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.loadScrolls = function() {\n    var scroll, _i, _len, _ref;\n    if (!this.scrolls) {\n      return;\n    }\n    _ref = this.scrolls;\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      scroll = _ref[_i];\n      scroll.el.scrollTop(scroll.scrollTop);\n      scroll.el.scrollLeft(scroll.scrollLeft);\n    }\n    return this.scrolls = null;\n  };\n\n  TreemaNode.prototype.keepFocus = function() {\n    this.saveScrolls();\n    this.getRootEl().focus();\n    return this.loadScrolls();\n  };\n\n  TreemaNode.prototype.copyData = function() {\n    return $.extend(null, {}, {\n      'd': this.data\n    })['d'];\n  };\n\n  TreemaNode.prototype.updateMyAddButton = function() {\n    this.$el.removeClass('treema-full');\n    if (!this.canAddChild()) {\n      return this.$el.addClass('treema-full');\n    }\n  };\n\n  TreemaNode.nodeMap = {};\n\n  TreemaNode.setNodeSubclass = function(key, NodeClass) {\n    return this.nodeMap[key] = NodeClass;\n  };\n\n  TreemaNode.make = function(element, options, parent, keyForParent) {\n    var NodeClass, key, localClasses, newNode, schema, tv4, type, value, workingData, workingSchema, workingSchemas, _ref, _ref1;\n    schema = options.schema || {};\n    if (schema.$ref) {\n      tv4 = options.tv4 || (parent != null ? parent.tv4 : void 0);\n      if (!tv4) {\n        tv4 = TreemaUtils.getGlobalTv4().freshApi();\n        tv4.addSchema('#', schema);\n      }\n      schema = this.utils.resolveReference(schema, tv4);\n    }\n    if ((schema[\"default\"] != null) && !((options.data != null) || (options.defaultData != null))) {\n      if ($.type(schema[\"default\"]) === 'object') {\n        options.data = {};\n      } else {\n        options.data = this.utils.cloneDeep(schema[\"default\"]);\n      }\n    }\n    workingData = options.data || options.defaultData;\n    workingSchemas = options.workingSchemas || this.utils.buildWorkingSchemas(schema, parent != null ? parent.tv4 : void 0);\n    workingSchema = options.workingSchema || this.utils.chooseWorkingSchema(workingData, workingSchemas, options.tv4);\n    this.massageData(options, workingSchema);\n    type = options.type || $.type((_ref = options.data) != null ? _ref : options.defaultData);\n    if (type === 'undefined') {\n      type = 'null';\n    }\n    localClasses = parent ? parent.settings.nodeClasses : options.nodeClasses;\n    NodeClass = this.getNodeClassForSchema(workingSchema, type, localClasses);\n    if (parent) {\n      _ref1 = parent.settings;\n      for (key in _ref1) {\n        value = _ref1[key];\n        if (key === 'data' || key === 'defaultData' || key === 'schema') {\n          continue;\n        }\n        options[key] = value;\n      }\n    }\n    options.workingSchema = workingSchema;\n    options.workingSchemas = workingSchemas;\n    if (keyForParent != null) {\n      options.keyForParent = keyForParent;\n    }\n    newNode = new NodeClass(element, options, parent);\n    return newNode;\n  };\n\n  TreemaNode.massageData = function(options, workingSchema) {\n    var dataType, defaultDataType, schemaTypes;\n    schemaTypes = workingSchema.type || ['string', 'number', 'integer', 'object', 'array', 'boolean', 'null'];\n    if ($.type(schemaTypes) !== 'array') {\n      schemaTypes = [schemaTypes];\n    }\n    if (__indexOf.call(schemaTypes, 'integer') >= 0 && __indexOf.call(schemaTypes, 'number') < 0) {\n      schemaTypes.push('number');\n    }\n    dataType = $.type(options.data);\n    defaultDataType = $.type(options.defaultData);\n    if (dataType !== 'undefined' && __indexOf.call(schemaTypes, dataType) < 0) {\n      options.data = this.defaultForType(schemaTypes[0]);\n    }\n    if (dataType === 'undefined' && __indexOf.call(schemaTypes, defaultDataType) < 0) {\n      return options.data = this.defaultForType(schemaTypes[0]);\n    }\n  };\n\n  TreemaNode.defaultForType = function(type) {\n    return TreemaNode.utils.defaultForType(type);\n  };\n\n  TreemaNode.getNodeClassForSchema = function(schema, def, localClasses) {\n    var NodeClass, type, typeMismatch, _ref;\n    if (def == null) {\n      def = 'string';\n    }\n    if (localClasses == null) {\n      localClasses = null;\n    }\n    typeMismatch = false;\n    if (schema.type) {\n      if ($.isArray(schema.type)) {\n        if (_ref = !def, __indexOf.call(schema.type, _ref) >= 0) {\n          typeMismatch = true;\n        }\n      } else {\n        typeMismatch = def !== schema.type;\n      }\n    }\n    NodeClass = null;\n    localClasses = localClasses || {};\n    if (schema.format) {\n      NodeClass = localClasses[schema.format] || this.nodeMap[schema.format];\n    }\n    if (NodeClass && !typeMismatch) {\n      return NodeClass;\n    }\n    type = schema.type || def;\n    if ($.isArray(type) || typeMismatch) {\n      type = def;\n    }\n    NodeClass = localClasses[type] || this.nodeMap[type];\n    if (NodeClass) {\n      return NodeClass;\n    }\n    return this.nodeMap['any'];\n  };\n\n  TreemaNode.extend = function(child) {\n    var ctor;\n    ctor = function() {};\n    ctor.prototype = this.prototype;\n    child.prototype = new ctor();\n    child.prototype.constructor = child;\n    child.__super__ = this.prototype;\n    child.prototype[\"super\"] = function(method) {\n      return this.constructor.__super__[method];\n    };\n    return child;\n  };\n\n  TreemaNode.didSelect = false;\n\n  TreemaNode.changedTreemas = [];\n\n  TreemaNode.prototype.filterChildren = function(filter) {\n    var keyForParent, treemaNode, _ref, _results;\n    _ref = this.childrenTreemas;\n    _results = [];\n    for (keyForParent in _ref) {\n      treemaNode = _ref[keyForParent];\n      _results.push(treemaNode.setFilterVisible(!filter || filter(treemaNode, keyForParent)));\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.clearFilter = function() {\n    var keyForParent, treemaNode, _ref, _results;\n    _ref = this.childrenTreemas;\n    _results = [];\n    for (keyForParent in _ref) {\n      treemaNode = _ref[keyForParent];\n      _results.push(treemaNode.setFilterVisible(true));\n    }\n    return _results;\n  };\n\n  TreemaNode.prototype.destroy = function() {\n    var child;\n    for (child in this.childrenTreemas) {\n      this.childrenTreemas[child].destroy();\n    }\n    return this.$el.remove();\n  };\n\n  return TreemaNode;\n\n})();\n;var __init,\n  __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n(__init = function() {\n  var ArrayNode, BooleanNode, IntegerNode, NullNode, NumberNode, ObjectNode, StringNode, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;\n  TreemaNode.setNodeSubclass('string', StringNode = (function(_super) {\n    __extends(StringNode, _super);\n\n    function StringNode() {\n      _ref = StringNode.__super__.constructor.apply(this, arguments);\n      return _ref;\n    }\n\n    StringNode.prototype.valueClass = 'treema-string';\n\n    StringNode.inputTypes = ['color', 'date', 'datetime', 'datetime-local', 'email', 'month', 'range', 'search', 'tel', 'text', 'time', 'url', 'week'];\n\n    StringNode.prototype.buildValueForDisplay = function(valEl, data) {\n      return this.buildValueForDisplaySimply(valEl, \"\\\"\" + data + \"\\\"\");\n    };\n\n    StringNode.prototype.buildValueForEditing = function(valEl, data) {\n      var input, _ref1;\n      input = this.buildValueForEditingSimply(valEl, data);\n      if (this.workingSchema.maxLength) {\n        input.attr('maxlength', this.workingSchema.maxLength);\n      }\n      if (_ref1 = this.workingSchema.format, __indexOf.call(StringNode.inputTypes, _ref1) >= 0) {\n        return input.attr('type', this.workingSchema.format);\n      }\n    };\n\n    StringNode.prototype.saveChanges = function(valEl) {\n      var oldData;\n      oldData = this.data;\n      this.data = $('input', valEl).val();\n      return StringNode.__super__.saveChanges.call(this, oldData);\n    };\n\n    return StringNode;\n\n  })(TreemaNode));\n  TreemaNode.setNodeSubclass('number', NumberNode = (function(_super) {\n    __extends(NumberNode, _super);\n\n    function NumberNode() {\n      _ref1 = NumberNode.__super__.constructor.apply(this, arguments);\n      return _ref1;\n    }\n\n    NumberNode.prototype.valueClass = 'treema-number';\n\n    NumberNode.prototype.buildValueForDisplay = function(valEl, data) {\n      return this.buildValueForDisplaySimply(valEl, JSON.stringify(data));\n    };\n\n    NumberNode.prototype.buildValueForEditing = function(valEl, data) {\n      var input;\n      input = this.buildValueForEditingSimply(valEl, JSON.stringify(data), 'number');\n      if (this.workingSchema.maximum) {\n        input.attr('max', this.workingSchema.maximum);\n      }\n      if (this.workingSchema.minimum) {\n        return input.attr('min', this.workingSchema.minimum);\n      }\n    };\n\n    NumberNode.prototype.saveChanges = function(valEl) {\n      var oldData;\n      oldData = this.data;\n      this.data = parseFloat($('input', valEl).val());\n      return NumberNode.__super__.saveChanges.call(this, oldData);\n    };\n\n    return NumberNode;\n\n  })(TreemaNode));\n  TreemaNode.setNodeSubclass('integer', IntegerNode = (function(_super) {\n    __extends(IntegerNode, _super);\n\n    function IntegerNode() {\n      _ref2 = IntegerNode.__super__.constructor.apply(this, arguments);\n      return _ref2;\n    }\n\n    IntegerNode.prototype.valueClass = 'treema-integer';\n\n    IntegerNode.prototype.buildValueForDisplay = function(valEl, data) {\n      return this.buildValueForDisplaySimply(valEl, JSON.stringify(data));\n    };\n\n    IntegerNode.prototype.buildValueForEditing = function(valEl, data) {\n      var input;\n      input = this.buildValueForEditingSimply(valEl, JSON.stringify(data), 'number');\n      if (this.workingSchema.maximum) {\n        input.attr('max', this.workingSchema.maximum);\n      }\n      if (this.workingSchema.minimum) {\n        return input.attr('min', this.workingSchema.minimum);\n      }\n    };\n\n    IntegerNode.prototype.saveChanges = function(valEl) {\n      var oldData;\n      oldData = this.data;\n      this.data = parseInt($('input', valEl).val());\n      return IntegerNode.__super__.saveChanges.call(this, oldData);\n    };\n\n    return IntegerNode;\n\n  })(TreemaNode));\n  TreemaNode.setNodeSubclass('null', NullNode = NullNode = (function(_super) {\n    __extends(NullNode, _super);\n\n    function NullNode() {\n      _ref3 = NullNode.__super__.constructor.apply(this, arguments);\n      return _ref3;\n    }\n\n    NullNode.prototype.valueClass = 'treema-null';\n\n    NullNode.prototype.editable = false;\n\n    NullNode.prototype.buildValueForDisplay = function(valEl) {\n      return this.buildValueForDisplaySimply(valEl, 'null');\n    };\n\n    return NullNode;\n\n  })(TreemaNode));\n  TreemaNode.setNodeSubclass('boolean', BooleanNode = (function(_super) {\n    __extends(BooleanNode, _super);\n\n    function BooleanNode() {\n      _ref4 = BooleanNode.__super__.constructor.apply(this, arguments);\n      return _ref4;\n    }\n\n    BooleanNode.prototype.valueClass = 'treema-boolean';\n\n    BooleanNode.prototype.buildValueForDisplay = function(valEl, data) {\n      this.buildValueForDisplaySimply(valEl, JSON.stringify(data));\n      return this.keepFocus();\n    };\n\n    BooleanNode.prototype.buildValueForEditing = function(valEl, data) {\n      var input;\n      input = this.buildValueForEditingSimply(valEl, JSON.stringify(data));\n      $('<span></span>').text(JSON.stringify(this.data)).insertBefore(input);\n      return input.focus();\n    };\n\n    BooleanNode.prototype.toggleValue = function(newValue) {\n      var oldData, valEl;\n      if (newValue == null) {\n        newValue = null;\n      }\n      oldData = this.getData();\n      this.data = !this.data;\n      if (newValue != null) {\n        this.data = newValue;\n      }\n      valEl = this.getValEl().empty();\n      if (this.isDisplaying()) {\n        this.buildValueForDisplay(valEl, this.getData());\n      } else {\n        this.buildValueForEditing(valEl, this.getData());\n      }\n      this.addTrackedAction({\n        'oldData': oldData,\n        'newData': this.data,\n        'path': this.getPath(),\n        'action': 'edit'\n      });\n      this.keepFocus();\n      return this.flushChanges();\n    };\n\n    BooleanNode.prototype.onSpacePressed = function() {\n      return this.toggleValue();\n    };\n\n    BooleanNode.prototype.onFPressed = function() {\n      return this.toggleValue(false);\n    };\n\n    BooleanNode.prototype.onTPressed = function() {\n      return this.toggleValue(true);\n    };\n\n    BooleanNode.prototype.saveChanges = function() {};\n\n    BooleanNode.prototype.onClick = function(e) {\n      var value;\n      value = $(e.target).closest('.treema-value');\n      if (!value.length) {\n        return BooleanNode.__super__.onClick.call(this, e);\n      }\n      if (this.canEdit()) {\n        return this.toggleValue();\n      }\n    };\n\n    return BooleanNode;\n\n  })(TreemaNode));\n  TreemaNode.setNodeSubclass('array', ArrayNode = (function(_super) {\n    __extends(ArrayNode, _super);\n\n    function ArrayNode() {\n      _ref5 = ArrayNode.__super__.constructor.apply(this, arguments);\n      return _ref5;\n    }\n\n    ArrayNode.prototype.valueClass = 'treema-array';\n\n    ArrayNode.prototype.collection = true;\n\n    ArrayNode.prototype.ordered = true;\n\n    ArrayNode.prototype.directlyEditable = false;\n\n    ArrayNode.prototype.sort = false;\n\n    ArrayNode.prototype.getChildren = function() {\n      var key, value, _i, _len, _ref6, _results;\n      _ref6 = this.getData();\n      _results = [];\n      for (key = _i = 0, _len = _ref6.length; _i < _len; key = ++_i) {\n        value = _ref6[key];\n        _results.push({\n          key: key,\n          value: value,\n          schema: this.getChildSchema(key)\n        });\n      }\n      return _results;\n    };\n\n    ArrayNode.prototype.buildValueForDisplay = function(valEl, data) {\n      var child, empty, helperTreema, index, text, val, _i, _len, _ref6;\n      text = [];\n      if (!data) {\n        return;\n      }\n      _ref6 = data.slice(0, 3);\n      for (index = _i = 0, _len = _ref6.length; _i < _len; index = ++_i) {\n        child = _ref6[index];\n        helperTreema = TreemaNode.make(null, {\n          schema: TreemaNode.utils.getChildSchema(index, this.workingSchema),\n          data: child\n        }, this);\n        val = $('<div></div>');\n        helperTreema.buildValueForDisplay(val, helperTreema.getData());\n        text.push(val.text());\n      }\n      if (data.length > 3) {\n        text.push('...');\n      }\n      empty = this.workingSchema.title != null ? \"(empty \" + this.workingSchema.title + \")\" : '(empty)';\n      text = text.length ? text.join(' | ') : empty;\n      return this.buildValueForDisplaySimply(valEl, text);\n    };\n\n    ArrayNode.prototype.buildValueForEditing = function(valEl, data) {\n      return this.buildValueForEditingSimply(valEl, JSON.stringify(data));\n    };\n\n    ArrayNode.prototype.canAddChild = function() {\n      if (this.settings.readOnly || this.workingSchema.readOnly) {\n        return false;\n      }\n      if (this.workingSchema.additionalItems === false && this.getData().length >= this.workingSchema.items.length) {\n        return false;\n      }\n      if ((this.workingSchema.maxItems != null) && this.getData().length >= this.workingSchema.maxItems) {\n        return false;\n      }\n      return true;\n    };\n\n    ArrayNode.prototype.addNewChild = function() {\n      var childNode, newTreema, new_index, schema;\n      if (!this.canAddChild()) {\n        return;\n      }\n      if (this.isClosed()) {\n        this.open();\n      }\n      new_index = Object.keys(this.childrenTreemas).length;\n      schema = TreemaNode.utils.getChildSchema(new_index, this.workingSchema);\n      newTreema = TreemaNode.make(void 0, {\n        schema: schema\n      }, this, new_index);\n      newTreema.tv4 = this.tv4;\n      childNode = this.createChildNode(newTreema);\n      this.addTrackedAction({\n        'data': newTreema.data,\n        'path': newTreema.getPath(),\n        'parentPath': this.getPath(),\n        'action': 'insert'\n      });\n      this.getAddButtonEl().before(childNode);\n      if (newTreema.canEdit()) {\n        newTreema.edit();\n      } else {\n        newTreema.select();\n        this.integrateChildTreema(newTreema);\n        newTreema.flushChanges();\n      }\n      return newTreema;\n    };\n\n    ArrayNode.prototype.open = function() {\n      if (this.data && this.sort) {\n        this.data.sort(this.sortFunction);\n      }\n      return ArrayNode.__super__.open.apply(this, arguments);\n    };\n\n    ArrayNode.prototype.close = function() {\n      var valEl;\n      ArrayNode.__super__.close.apply(this, arguments);\n      valEl = this.getValEl().empty();\n      return this.buildValueForDisplay(valEl, this.getData());\n    };\n\n    ArrayNode.prototype.sortFunction = function(a, b) {\n      if (a > b) {\n        return 1;\n      }\n      if (a < b) {\n        return -1;\n      }\n      return 0;\n    };\n\n    return ArrayNode;\n\n  })(TreemaNode));\n  window.TreemaArrayNode = ArrayNode;\n  TreemaNode.setNodeSubclass('object', ObjectNode = (function(_super) {\n    __extends(ObjectNode, _super);\n\n    function ObjectNode() {\n      this.cleanupAddNewChild = __bind(this.cleanupAddNewChild, this);\n      this.onAutocompleteSelect = __bind(this.onAutocompleteSelect, this);\n      _ref6 = ObjectNode.__super__.constructor.apply(this, arguments);\n      return _ref6;\n    }\n\n    ObjectNode.prototype.valueClass = 'treema-object';\n\n    ObjectNode.prototype.collection = true;\n\n    ObjectNode.prototype.keyed = true;\n\n    ObjectNode.prototype.directlyEditable = false;\n\n    ObjectNode.prototype.getChildren = function() {\n      var children, defaultData, key, keysAccountedFor, schema, value, _ref7;\n      children = [];\n      keysAccountedFor = [];\n      if (this.workingSchema.properties) {\n        for (key in this.workingSchema.properties) {\n          defaultData = this.getDefaultDataForKey(key);\n          if ($.type(this.getData()[key]) === 'undefined') {\n            if (defaultData != null) {\n              keysAccountedFor.push(key);\n              children.push({\n                key: key,\n                schema: this.getChildSchema(key),\n                defaultData: defaultData\n              });\n            }\n            continue;\n          }\n          keysAccountedFor.push(key);\n          schema = this.getChildSchema(key);\n          children.push({\n            key: key,\n            value: this.getData()[key],\n            schema: schema,\n            defaultData: defaultData\n          });\n        }\n      }\n      _ref7 = this.getData();\n      for (key in _ref7) {\n        value = _ref7[key];\n        if (__indexOf.call(keysAccountedFor, key) >= 0) {\n          continue;\n        }\n        keysAccountedFor.push(key);\n        children.push({\n          key: key,\n          value: value,\n          schema: this.getChildSchema(key),\n          defaultData: this.getDefaultDataForKey(key)\n        });\n      }\n      if ($.isPlainObject(this.defaultData)) {\n        for (key in this.defaultData) {\n          if (__indexOf.call(keysAccountedFor, key) >= 0) {\n            continue;\n          }\n          keysAccountedFor.push(key);\n          children.push({\n            key: key,\n            schema: this.getChildSchema(key),\n            defaultData: this.getDefaultDataForKey(key)\n          });\n        }\n      }\n      if ($.isPlainObject(this.workingSchema[\"default\"])) {\n        for (key in this.workingSchema[\"default\"]) {\n          if (__indexOf.call(keysAccountedFor, key) >= 0) {\n            continue;\n          }\n          keysAccountedFor.push(key);\n          children.push({\n            key: key,\n            schema: this.getChildSchema(key),\n            defaultData: this.getDefaultDataForKey(key)\n          });\n        }\n      }\n      return children;\n    };\n\n    ObjectNode.prototype.getDefaultDataForKey = function(key) {\n      var childDefaultData, _ref7, _ref8, _ref9;\n      childDefaultData = (_ref7 = (_ref8 = this.defaultData) != null ? _ref8[key] : void 0) != null ? _ref7 : (_ref9 = this.workingSchema[\"default\"]) != null ? _ref9[key] : void 0;\n      if ($.isArray(childDefaultData)) {\n        childDefaultData = $.extend(true, [], childDefaultData);\n      }\n      if ($.isPlainObject(childDefaultData)) {\n        childDefaultData = $.extend(true, {}, childDefaultData);\n      }\n      return childDefaultData;\n    };\n\n    ObjectNode.prototype.buildValueForDisplay = function(valEl, data) {\n      var childSchema, displayValue, empty, i, key, name, schema, text, value, valueString;\n      text = [];\n      if (!data) {\n        return;\n      }\n      displayValue = data[this.workingSchema.displayProperty];\n      if (displayValue) {\n        text = displayValue;\n        return this.buildValueForDisplaySimply(valEl, text);\n      }\n      i = 0;\n      schema = this.workingSchema || this.schema;\n      for (key in data) {\n        value = data[key];\n        if (value === void 0) {\n          continue;\n        }\n        if (i === 3) {\n          text.push('...');\n          break;\n        }\n        i += 1;\n        childSchema = this.getChildSchema(key);\n        name = childSchema.title || key;\n        if ($.isPlainObject(value) || $.isArray(value)) {\n          text.push(\"\" + name);\n          continue;\n        }\n        valueString = value;\n        if ($.type(value) !== 'string') {\n          valueString = JSON.stringify(value);\n        }\n        if (typeof value === 'undefined') {\n          valueString = 'undefined';\n        }\n        if (valueString.length > 20) {\n          valueString = valueString.slice(0, 21) + ' ...';\n        }\n        text.push(\"\" + name + \"=\" + valueString);\n      }\n      empty = this.workingSchema.title != null ? \"(empty \" + this.workingSchema.title + \")\" : '(empty)';\n      text = text.length ? text.join(', ') : empty;\n      return this.buildValueForDisplaySimply(valEl, text);\n    };\n\n    ObjectNode.prototype.populateData = function() {\n      ObjectNode.__super__.populateData.call(this);\n      return TreemaNode.utils.populateRequireds(this.data, this.workingSchema, this.tv4);\n    };\n\n    ObjectNode.prototype.close = function() {\n      ObjectNode.__super__.close.apply(this, arguments);\n      return this.buildValueForDisplay(this.getValEl().empty(), this.getData());\n    };\n\n    ObjectNode.prototype.addNewChild = function() {\n      var keyInput, properties,\n        _this = this;\n      if (!this.canAddChild()) {\n        return;\n      }\n      if (!this.isRoot()) {\n        this.open();\n      }\n      this.deselectAll();\n      properties = this.childPropertiesAvailable();\n      keyInput = $(this.newPropertyTemplate);\n      keyInput.blur(this.cleanupAddNewChild);\n      keyInput.keydown(function(e) {\n        return _this.originalTargetValue = $(e.target).val();\n      });\n      if (typeof keyInput.autocomplete === \"function\") {\n        keyInput.autocomplete({\n          source: properties,\n          minLength: 0,\n          delay: 0,\n          autoFocus: true,\n          select: this.onAutocompleteSelect\n        });\n      }\n      this.getAddButtonEl().before(keyInput).hide();\n      keyInput.focus();\n      keyInput.autocomplete('search');\n      return true;\n    };\n\n    ObjectNode.prototype.onAutocompleteSelect = function(e, ui) {\n      $(e.target).val(ui.item.value);\n      return this.tryToAddNewChild(e, true);\n    };\n\n    ObjectNode.prototype.canAddChild = function() {\n      if (this.settings.readOnly || this.workingSchema.readOnly) {\n        return false;\n      }\n      if ((this.workingSchema.maxProperties != null) && Object.keys(this.getData()).length >= this.workingSchema.maxProperties) {\n        return false;\n      }\n      if (this.workingSchema.additionalProperties !== false) {\n        return true;\n      }\n      if (this.workingSchema.patternProperties != null) {\n        return true;\n      }\n      if (this.childPropertiesAvailable().length) {\n        return true;\n      }\n      return false;\n    };\n\n    ObjectNode.prototype.childPropertiesAvailable = function() {\n      var childSchema, data, properties, property, schema, _ref7;\n      schema = this.workingSchema || this.schema;\n      if (!schema.properties) {\n        return [];\n      }\n      properties = [];\n      data = this.getData();\n      _ref7 = schema.properties;\n      for (property in _ref7) {\n        childSchema = _ref7[property];\n        if ((data != null ? data[property] : void 0) != null) {\n          continue;\n        }\n        if (childSchema.format === 'hidden') {\n          continue;\n        }\n        if (childSchema.readOnly) {\n          continue;\n        }\n        properties.push(childSchema.title || property);\n      }\n      return properties.sort();\n    };\n\n    ObjectNode.prototype.onDeletePressed = function(e) {\n      if (!this.addingNewProperty()) {\n        return ObjectNode.__super__.onDeletePressed.call(this, e);\n      }\n      if (!$(e.target).val()) {\n        this.cleanupAddNewChild();\n        e.preventDefault();\n        return this.$el.find('.treema-add-child').focus();\n      }\n    };\n\n    ObjectNode.prototype.onEscapePressed = function() {\n      return this.cleanupAddNewChild();\n    };\n\n    ObjectNode.prototype.onTabPressed = function(e) {\n      if (!this.addingNewProperty()) {\n        return ObjectNode.__super__.onTabPressed.call(this, e);\n      }\n      e.preventDefault();\n      return this.tryToAddNewChild(e, false);\n    };\n\n    ObjectNode.prototype.onEnterPressed = function(e) {\n      if (!this.addingNewProperty()) {\n        return ObjectNode.__super__.onEnterPressed.call(this, e);\n      }\n      return this.tryToAddNewChild(e, true);\n    };\n\n    ObjectNode.prototype.tryToAddNewChild = function(e, aggressive) {\n      var key, keyInput, offset, treema;\n      if ((!this.originalTargetValue) && (!aggressive)) {\n        offset = e.shiftKey ? -1 : 1;\n        this.cleanupAddNewChild();\n        this.$el.find('.treema-add-child').focus();\n        this.traverseWhileEditing(offset);\n        return;\n      }\n      keyInput = $(e.target);\n      key = this.getPropertyKey($(e.target));\n      if (key.length && !this.canAddProperty(key)) {\n        this.clearTemporaryErrors();\n        this.showBadPropertyError(keyInput);\n        return;\n      }\n      if (this.childrenTreemas[key] != null) {\n        this.cleanupAddNewChild();\n        treema = this.childrenTreemas[key];\n        if (treema.canEdit()) {\n          return treema.toggleEdit();\n        } else {\n          return treema.select();\n        }\n      }\n      this.cleanupAddNewChild();\n      return this.addNewChildForKey(key);\n    };\n\n    ObjectNode.prototype.getPropertyKey = function(keyInput) {\n      var child_key, child_schema, key, _ref7;\n      key = keyInput.val();\n      if (this.workingSchema.properties) {\n        _ref7 = this.workingSchema.properties;\n        for (child_key in _ref7) {\n          child_schema = _ref7[child_key];\n          if (child_schema.title === key) {\n            key = child_key;\n          }\n        }\n      }\n      return key;\n    };\n\n    ObjectNode.prototype.canAddProperty = function(key) {\n      var pattern, _ref7;\n      if (this.workingSchema.additionalProperties !== false) {\n        return true;\n      }\n      if (((_ref7 = this.workingSchema.properties) != null ? _ref7[key] : void 0) != null) {\n        return true;\n      }\n      if (this.workingSchema.patternProperties != null) {\n        for (pattern in this.workingSchema.patternProperties) {\n          if (RegExp(pattern).test(key)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n\n    ObjectNode.prototype.showBadPropertyError = function(keyInput) {\n      var tempError;\n      keyInput.focus();\n      tempError = this.createTemporaryError('Invalid property name.');\n      tempError.insertAfter(keyInput);\n    };\n\n    ObjectNode.prototype.addNewChildForKey = function(key) {\n      var child, childNode, children, newTreema, schema;\n      schema = this.getChildSchema(key);\n      newTreema = TreemaNode.make(null, {\n        schema: schema\n      }, this, key);\n      childNode = this.createChildNode(newTreema);\n      this.findObjectInsertionPoint(key).before(childNode);\n      if (newTreema.canEdit()) {\n        newTreema.edit();\n      } else {\n        this.integrateChildTreema(newTreema);\n        if (newTreema.collection) {\n          children = newTreema.getChildren();\n          if (children.length) {\n            newTreema.open();\n            child = newTreema.childrenTreemas[children[0]['key']];\n            if (child != null) {\n              child.select();\n            }\n          } else {\n            newTreema.addNewChild();\n          }\n        }\n      }\n      this.addTrackedAction({\n        'data': newTreema.data,\n        'path': newTreema.getPath(),\n        'parentPath': this.getPath(),\n        action: 'insert'\n      });\n      return this.updateMyAddButton();\n    };\n\n    ObjectNode.prototype.findObjectInsertionPoint = function(key) {\n      var afterKeys, allChildren, allProps, child, _i, _len, _ref7, _ref8;\n      if (!((_ref7 = this.workingSchema.properties) != null ? _ref7[key] : void 0)) {\n        return this.getAddButtonEl();\n      }\n      allProps = Object.keys(this.workingSchema.properties);\n      afterKeys = allProps.slice(allProps.indexOf(key) + 1);\n      allChildren = this.$el.find('> .treema-children > .treema-node');\n      for (_i = 0, _len = allChildren.length; _i < _len; _i++) {\n        child = allChildren[_i];\n        if (_ref8 = $(child).data('instance').keyForParent, __indexOf.call(afterKeys, _ref8) >= 0) {\n          return $(child);\n        }\n      }\n      return this.getAddButtonEl();\n    };\n\n    ObjectNode.prototype.cleanupAddNewChild = function() {\n      this.$el.find('.treema-new-prop').remove();\n      this.getAddButtonEl().show();\n      return this.clearTemporaryErrors();\n    };\n\n    ObjectNode.prototype.addingNewProperty = function() {\n      return document.activeElement === this.$el.find('.treema-new-prop')[0];\n    };\n\n    return ObjectNode;\n\n  })(TreemaNode));\n  return window.TreemaObjectNode = ObjectNode;\n})();\n;var __hasProp = {}.hasOwnProperty,\n  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n  __slice = [].slice;\n\n(function() {\n  var AceNode, DatabaseSearchTreemaNode, LongStringNode, Point2DNode, Point3DNode, debounce, _ref, _ref1, _ref2, _ref3, _ref4;\n  TreemaNode.setNodeSubclass('point2d', Point2DNode = (function(_super) {\n    __extends(Point2DNode, _super);\n\n    function Point2DNode() {\n      _ref = Point2DNode.__super__.constructor.apply(this, arguments);\n      return _ref;\n    }\n\n    Point2DNode.prototype.valueClass = 'treema-point2d';\n\n    Point2DNode.prototype.buildValueForDisplay = function(valEl, data) {\n      return this.buildValueForDisplaySimply(valEl, \"(\" + data.x + \", \" + data.y + \")\");\n    };\n\n    Point2DNode.prototype.buildValueForEditing = function(valEl, data) {\n      var xInput, yInput;\n      xInput = $('<input />').val(data.x).attr('placeholder', 'x');\n      yInput = $('<input />').val(data.y).attr('placeholder', 'y');\n      valEl.append('(').append(xInput).append(', ').append(yInput).append(')');\n      return valEl.find('input:first').focus().select();\n    };\n\n    Point2DNode.prototype.saveChanges = function(valEl) {\n      if (this.data == null) {\n        this.data = {};\n      }\n      this.data.x = parseFloat(valEl.find('input:first').val());\n      return this.data.y = parseFloat(valEl.find('input:last').val());\n    };\n\n    return Point2DNode;\n\n  })(TreemaNode));\n  TreemaNode.setNodeSubclass('point3d', Point3DNode = (function(_super) {\n    __extends(Point3DNode, _super);\n\n    function Point3DNode() {\n      _ref1 = Point3DNode.__super__.constructor.apply(this, arguments);\n      return _ref1;\n    }\n\n    Point3DNode.prototype.valueClass = 'treema-point3d';\n\n    Point3DNode.prototype.buildValueForDisplay = function(valEl, data) {\n      return this.buildValueForDisplaySimply(valEl, \"(\" + data.x + \", \" + data.y + \", \" + data.z + \")\");\n    };\n\n    Point3DNode.prototype.buildValueForEditing = function(valEl, data) {\n      var xInput, yInput, zInput;\n      xInput = $('<input />').val(data.x).attr('placeholder', 'x');\n      yInput = $('<input />').val(data.y).attr('placeholder', 'y');\n      zInput = $('<input />').val(data.z).attr('placeholder', 'z');\n      valEl.append('(').append(xInput).append(', ').append(yInput).append(', ').append(zInput).append(')');\n      return valEl.find('input:first').focus().select();\n    };\n\n    Point3DNode.prototype.saveChanges = function() {\n      var inputs;\n      inputs = this.getInputs();\n      if (this.data == null) {\n        this.data = {};\n      }\n      this.data.x = parseFloat($(inputs[0]).val());\n      this.data.y = parseFloat($(inputs[1]).val());\n      return this.data.z = parseFloat($(inputs[2]).val());\n    };\n\n    return Point3DNode;\n\n  })(TreemaNode));\n  DatabaseSearchTreemaNode = (function(_super) {\n    __extends(DatabaseSearchTreemaNode, _super);\n\n    function DatabaseSearchTreemaNode() {\n      this.searchCallback = __bind(this.searchCallback, this);\n      this.search = __bind(this.search, this);\n      _ref2 = DatabaseSearchTreemaNode.__super__.constructor.apply(this, arguments);\n      return _ref2;\n    }\n\n    DatabaseSearchTreemaNode.prototype.valueClass = 'treema-search';\n\n    DatabaseSearchTreemaNode.prototype.searchValueTemplate = '<input placeholder=\"Search\" /><div class=\"treema-search-results\"></div>';\n\n    DatabaseSearchTreemaNode.prototype.url = null;\n\n    DatabaseSearchTreemaNode.prototype.lastTerm = null;\n\n    DatabaseSearchTreemaNode.prototype.buildValueForDisplay = function(valEl, data) {\n      var val;\n      val = data ? this.formatDocument(data) : 'None';\n      return this.buildValueForDisplaySimply(valEl, val);\n    };\n\n    DatabaseSearchTreemaNode.prototype.formatDocument = function(doc) {\n      if ($.isString(doc)) {\n        return doc;\n      }\n      return JSON.stringify(doc);\n    };\n\n    DatabaseSearchTreemaNode.prototype.buildValueForEditing = function(valEl, data) {\n      var input;\n      valEl.html(this.searchValueTemplate);\n      input = valEl.find('input');\n      input.focus().keyup(this.search);\n      if (data) {\n        return input.attr('placeholder', this.formatDocument(data));\n      }\n    };\n\n    DatabaseSearchTreemaNode.prototype.search = function() {\n      var term;\n      term = this.getValEl().find('input').val();\n      if (term === this.lastTerm) {\n        return;\n      }\n      if (this.lastTerm && !term) {\n        this.getSearchResultsEl().empty();\n      }\n      if (!term) {\n        return;\n      }\n      this.lastTerm = term;\n      this.getSearchResultsEl().empty().append('Searching');\n      return $.ajax(this.url + '?term=' + term, {\n        dataType: 'json',\n        success: this.searchCallback\n      });\n    };\n\n    DatabaseSearchTreemaNode.prototype.searchCallback = function(results) {\n      var container, first, i, result, row, text, _i, _len;\n      container = this.getSearchResultsEl().detach().empty();\n      first = true;\n      for (i = _i = 0, _len = results.length; _i < _len; i = ++_i) {\n        result = results[i];\n        row = $('<div></div>').addClass('treema-search-result-row');\n        text = this.formatDocument(result);\n        if (text == null) {\n          continue;\n        }\n        if (first) {\n          row.addClass('treema-search-selected');\n        }\n        first = false;\n        row.text(text);\n        row.data('value', result);\n        container.append(row);\n      }\n      if (!results.length) {\n        container.append($('<div>No results</div>'));\n      }\n      return this.getValEl().append(container);\n    };\n\n    DatabaseSearchTreemaNode.prototype.getSearchResultsEl = function() {\n      return this.getValEl().find('.treema-search-results');\n    };\n\n    DatabaseSearchTreemaNode.prototype.getSelectedResultEl = function() {\n      return this.getValEl().find('.treema-search-selected');\n    };\n\n    DatabaseSearchTreemaNode.prototype.saveChanges = function() {\n      var selected;\n      selected = this.getSelectedResultEl();\n      if (!selected.length) {\n        return;\n      }\n      return this.data = selected.data('value');\n    };\n\n    DatabaseSearchTreemaNode.prototype.onDownArrowPressed = function(e) {\n      this.navigateSearch(1);\n      return e.preventDefault();\n    };\n\n    DatabaseSearchTreemaNode.prototype.onUpArrowPressed = function(e) {\n      e.preventDefault();\n      return this.navigateSearch(-1);\n    };\n\n    DatabaseSearchTreemaNode.prototype.navigateSearch = function(offset) {\n      var func, next, selected;\n      selected = this.getSelectedResultEl();\n      func = offset > 0 ? 'next' : 'prev';\n      next = selected[func]('.treema-search-result-row');\n      if (!next.length) {\n        return;\n      }\n      selected.removeClass('treema-search-selected');\n      return next.addClass('treema-search-selected');\n    };\n\n    DatabaseSearchTreemaNode.prototype.onClick = function(e) {\n      var newSelection;\n      newSelection = $(e.target).closest('.treema-search-result-row');\n      if (!newSelection.length) {\n        return DatabaseSearchTreemaNode.__super__.onClick.call(this, e);\n      }\n      this.getSelectedResultEl().removeClass('treema-search-selected');\n      newSelection.addClass('treema-search-selected');\n      this.saveChanges();\n      return this.display();\n    };\n\n    DatabaseSearchTreemaNode.prototype.shouldTryToRemoveFromParent = function() {\n      var selected;\n      if (this.getData() != null) {\n        return;\n      }\n      selected = this.getSelectedResultEl();\n      return !selected.length;\n    };\n\n    return DatabaseSearchTreemaNode;\n\n  })(TreemaNode);\n  debounce = function(func, threshold, execAsap) {\n    var timeout;\n    timeout = null;\n    return function() {\n      var args, delayed, obj;\n      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n      obj = this;\n      delayed = function() {\n        if (!execAsap) {\n          func.apply(obj, args);\n        }\n        return timeout = null;\n      };\n      if (timeout) {\n        clearTimeout(timeout);\n      } else if (execAsap) {\n        func.apply(obj, args);\n      }\n      return timeout = setTimeout(delayed, threshold || 100);\n    };\n  };\n  DatabaseSearchTreemaNode.prototype.search = debounce(DatabaseSearchTreemaNode.prototype.search, 200);\n  window.DatabaseSearchTreemaNode = DatabaseSearchTreemaNode;\n  TreemaNode.setNodeSubclass('ace', AceNode = (function(_super) {\n    __extends(AceNode, _super);\n\n    function AceNode() {\n      this.saveChanges = __bind(this.saveChanges, this);\n      _ref3 = AceNode.__super__.constructor.apply(this, arguments);\n      return _ref3;\n    }\n\n    AceNode.prototype.valueClass = 'treema-ace treema-multiline';\n\n    AceNode.prototype.initEditor = function(valEl) {\n      var d, session;\n      d = $('<div></div>').text(this.getData());\n      valEl.append(d);\n      this.editor = ace.edit(d[0]);\n      session = this.editor.getSession();\n      if (this.schema.aceMode != null) {\n        session.setMode(this.schema.aceMode);\n      }\n      if (this.schema.aceTabSize != null) {\n        session.setTabSize(this.schema.aceTabSize);\n      }\n      if (this.schema.aceUseWrapMode != null) {\n        session.setUseWrapMode(this.schema.aceUseWrapMode);\n      }\n      session.setNewLineMode(\"unix\");\n      session.setUseSoftTabs(true);\n      session.on('change', this.saveChanges);\n      this.editor.setOptions({\n        maxLines: Infinity\n      });\n      if (this.schema.aceTheme != null) {\n        this.editor.setTheme(this.schema.aceTheme);\n      }\n      return this.editor.$blockScrolling = Infinity;\n    };\n\n    AceNode.prototype.toggleEdit = function() {\n      if (!this.editor) {\n        this.initEditor(this.getValEl());\n      }\n      return this.deselectAll();\n    };\n\n    AceNode.prototype.buildValueForDisplay = function(valEl) {\n      if (!this.editor) {\n        return this.initEditor(valEl);\n      }\n    };\n\n    AceNode.prototype.buildValueForEditing = function() {};\n\n    AceNode.prototype.saveChanges = function() {\n      this.data = this.editor.getValue();\n      this.flushChanges();\n      return this.broadcastChanges();\n    };\n\n    AceNode.prototype.onTabPressed = function() {};\n\n    AceNode.prototype.onEnterPressed = function() {};\n\n    AceNode.prototype.destroy = function() {\n      var session;\n      if (this.editor) {\n        session = this.editor.getSession();\n        session.setMode('');\n        return this.editor.destroy();\n      }\n    };\n\n    return AceNode;\n\n  })(TreemaNode));\n  return TreemaNode.setNodeSubclass('long-string', LongStringNode = (function(_super) {\n    __extends(LongStringNode, _super);\n\n    function LongStringNode() {\n      _ref4 = LongStringNode.__super__.constructor.apply(this, arguments);\n      return _ref4;\n    }\n\n    LongStringNode.prototype.valueClass = 'treema-long-string treema-multiline';\n\n    LongStringNode.prototype.buildValueForDisplay = function(valEl, data) {\n      var text;\n      text = data.replace(/\\n/g, '<br />');\n      return valEl.append($(\"<div></div>\").html(text));\n    };\n\n    LongStringNode.prototype.buildValueForEditing = function(valEl, data) {\n      var input;\n      input = $('<textarea />');\n      if (data !== null) {\n        input.val(data);\n      }\n      valEl.append(input);\n      input.focus().select();\n      input.blur(this.onEditInputBlur);\n      return input;\n    };\n\n    LongStringNode.prototype.saveChanges = function(valEl) {\n      var input;\n      input = valEl.find('textarea');\n      return this.data = input.val();\n    };\n\n    return LongStringNode;\n\n  })(TreemaNode));\n})();\n;(function($) {\n  return $.fn[TreemaNode.pluginName] = function(options) {\n    var element;\n    if (this.length === 0) {\n      return null;\n    }\n    element = $(this[0]);\n    return TreemaNode.make(element, options);\n  };\n})(jQuery);\n;var TreemaUtils;\n\nTreemaUtils = (function() {\n  var utils;\n  utils = {};\n  utils.populateDefaults = function(rootData, rootSchema, tv4) {\n    var _this = this;\n    if (rootSchema[\"default\"] && !rootData) {\n      rootData = this.cloneDeep(rootSchema[\"default\"]);\n    }\n    this.walk(rootData, rootSchema, tv4, function(path, data, schema) {\n      var def, key, value, _results;\n      def = schema[\"default\"];\n      if (!(_this.type(def) === 'object' && _this.type(data) === 'object')) {\n        return;\n      }\n      _results = [];\n      for (key in def) {\n        value = def[key];\n        if (data[key] === void 0) {\n          _results.push(data[key] = _this.cloneDeep(value));\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    });\n    return rootData;\n  };\n  utils.populateRequireds = function(rootData, rootSchema, tv4) {\n    var _this = this;\n    if (rootData == null) {\n      rootData = {};\n    }\n    this.walk(rootData, rootSchema, tv4, function(path, data, schema) {\n      var childSchema, key, schemaDefault, type, workingSchema, _i, _len, _ref, _ref1, _results;\n      if (!(schema.required && _this.type(data) === 'object')) {\n        return;\n      }\n      _ref = schema.required;\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        key = _ref[_i];\n        if (data[key] != null) {\n          continue;\n        }\n        if (schemaDefault = (_ref1 = schema[\"default\"]) != null ? _ref1[key] : void 0) {\n          _results.push(data[key] = _this.cloneDeep(schemaDefault));\n        } else {\n          childSchema = _this.getChildSchema(key, schema);\n          workingSchema = _this.buildWorkingSchemas(childSchema, tv4)[0];\n          schemaDefault = workingSchema[\"default\"];\n          if (schemaDefault != null) {\n            _results.push(data[key] = _this.cloneDeep(schemaDefault));\n          } else {\n            type = workingSchema.type;\n            if (_this.type(type) === 'array') {\n              type = type[0];\n            }\n            if (!type) {\n              type = 'string';\n            }\n            _results.push(data[key] = _this.defaultForType(type));\n          }\n        }\n      }\n      return _results;\n    });\n    return rootData;\n  };\n  utils.walk = function(data, schema, tv4, callback, path) {\n    var dataType, f, key, value, workingSchema, workingSchemas, _i, _len, _results, _results1,\n      _this = this;\n    if (path == null) {\n      path = '';\n    }\n    if (!tv4) {\n      tv4 = this.getGlobalTv4().freshApi();\n      tv4.addSchema('#', schema);\n      if (schema.id) {\n        tv4.addSchema(schema.id, schema);\n      }\n    }\n    workingSchemas = this.buildWorkingSchemas(schema, tv4);\n    workingSchema = this.chooseWorkingSchema(data, workingSchemas, tv4);\n    callback(path, data, workingSchema);\n    dataType = this.type(data);\n    if (dataType === 'array' || dataType === 'object') {\n      f = function(key, value) {\n        var childPath, childSchema;\n        value = data[key];\n        childPath = path.slice();\n        if (childPath) {\n          childPath += '.';\n        }\n        childPath += key;\n        childSchema = _this.getChildSchema(key, workingSchema);\n        return _this.walk(value, childSchema, tv4, callback, childPath);\n      };\n      if (dataType === 'array') {\n        _results = [];\n        for (key = _i = 0, _len = data.length; _i < _len; key = ++_i) {\n          value = data[key];\n          _results.push(f(key, value));\n        }\n        return _results;\n      } else {\n        _results1 = [];\n        for (key in data) {\n          value = data[key];\n          _results1.push(f(key, value));\n        }\n        return _results1;\n      }\n    }\n  };\n  utils.getChildSchema = function(key, schema) {\n    var childKey, childSchema, index, _ref, _ref1;\n    if (this.type(key) === 'string') {\n      _ref = schema.properties;\n      for (childKey in _ref) {\n        childSchema = _ref[childKey];\n        if (childKey === key) {\n          return childSchema;\n        }\n      }\n      _ref1 = schema.patternProperties;\n      for (childKey in _ref1) {\n        childSchema = _ref1[childKey];\n        if (key.match(new RegExp(childKey))) {\n          return childSchema;\n        }\n      }\n      if (typeof schema.additionalProperties === 'object') {\n        return schema.additionalProperties;\n      }\n    }\n    if (this.type(key) === 'number') {\n      index = key;\n      if (schema.items) {\n        if (Array.isArray(schema.items)) {\n          if (index < schema.items.length) {\n            return schema.items[index];\n          } else if (schema.additionalItems) {\n            return schema.additionalItems;\n          }\n        } else if (schema.items) {\n          return schema.items;\n        }\n      }\n    }\n    return {};\n  };\n  utils.buildWorkingSchemas = function(schema, tv4) {\n    var allOf, anyOf, baseSchema, newBase, oneOf, singularSchema, singularSchemas, workingSchemas, _i, _j, _len, _len1;\n    if (schema == null) {\n      schema = {};\n    }\n    baseSchema = this.resolveReference(schema, tv4);\n    if (!(schema.allOf || schema.anyOf || schema.oneOf)) {\n      return [schema];\n    }\n    baseSchema = this.cloneSchema(baseSchema);\n    allOf = baseSchema.allOf;\n    anyOf = baseSchema.anyOf;\n    oneOf = baseSchema.oneOf;\n    if (baseSchema.allOf != null) {\n      delete baseSchema.allOf;\n    }\n    if (baseSchema.anyOf != null) {\n      delete baseSchema.anyOf;\n    }\n    if (baseSchema.oneOf != null) {\n      delete baseSchema.oneOf;\n    }\n    if (allOf != null) {\n      for (_i = 0, _len = allOf.length; _i < _len; _i++) {\n        schema = allOf[_i];\n        this.combineSchemas(baseSchema, this.resolveReference(schema, tv4));\n      }\n    }\n    workingSchemas = [];\n    singularSchemas = [];\n    if (anyOf != null) {\n      singularSchemas = singularSchemas.concat(anyOf);\n    }\n    if (oneOf != null) {\n      singularSchemas = singularSchemas.concat(oneOf);\n    }\n    for (_j = 0, _len1 = singularSchemas.length; _j < _len1; _j++) {\n      singularSchema = singularSchemas[_j];\n      singularSchema = this.resolveReference(singularSchema, tv4);\n      newBase = this.cloneSchema(baseSchema);\n      this.combineSchemas(newBase, singularSchema);\n      workingSchemas.push(newBase);\n    }\n    if (workingSchemas.length === 0) {\n      workingSchemas = [baseSchema];\n    }\n    return workingSchemas;\n  };\n  utils.chooseWorkingSchema = function(data, workingSchemas, tv4) {\n    var result, schema, _i, _len;\n    if (workingSchemas.length === 1) {\n      return workingSchemas[0];\n    }\n    if (tv4 == null) {\n      tv4 = this.getGlobalTv4();\n    }\n    for (_i = 0, _len = workingSchemas.length; _i < _len; _i++) {\n      schema = workingSchemas[_i];\n      result = tv4.validateMultiple(data, schema);\n      if (result.valid) {\n        return schema;\n      }\n    }\n    return workingSchemas[0];\n  };\n  utils.resolveReference = function(schema, tv4, scrubTitle) {\n    var resolved;\n    if (scrubTitle == null) {\n      scrubTitle = false;\n    }\n    if (schema.$ref == null) {\n      return schema;\n    }\n    if (tv4 == null) {\n      tv4 = this.getGlobalTv4();\n    }\n    resolved = tv4.getSchema(schema.$ref);\n    if (!resolved) {\n      console.warn('could not resolve reference', schema.$ref, tv4.getMissingUris());\n    }\n    if (resolved == null) {\n      resolved = {};\n    }\n    if (scrubTitle && (resolved.title != null)) {\n      delete resolved.title;\n    }\n    return resolved;\n  };\n  utils.getGlobalTv4 = function() {\n    if (typeof window !== 'undefined') {\n      return window.tv4;\n    }\n    if (typeof global !== 'undefined') {\n      return global.tv4;\n    }\n    if (typeof tv4 !== 'undefined') {\n      return tv4;\n    }\n  };\n  utils.cloneSchema = function(schema) {\n    var clone, key, value;\n    clone = {};\n    for (key in schema) {\n      value = schema[key];\n      clone[key] = value;\n    }\n    return clone;\n  };\n  utils.combineSchemas = function(schema1, schema2) {\n    var key, value;\n    for (key in schema2) {\n      value = schema2[key];\n      schema1[key] = value;\n    }\n    return schema1;\n  };\n  utils.cloneDeep = function(data) {\n    var clone, key, type, value;\n    clone = data;\n    type = this.type(data);\n    if (type === 'object') {\n      clone = {};\n    }\n    if (type === 'array') {\n      clone = [];\n    }\n    if (type === 'object' || type === 'array') {\n      for (key in data) {\n        value = data[key];\n        clone[key] = this.cloneDeep(value);\n      }\n    }\n    return clone;\n  };\n  utils.type = (function() {\n    var classToType, name, _i, _len, _ref;\n    classToType = {};\n    _ref = \"Boolean Number String Function Array Date RegExp Undefined Null\".split(\" \");\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      name = _ref[_i];\n      classToType[\"[object \" + name + \"]\"] = name.toLowerCase();\n    }\n    return function(obj) {\n      var strType;\n      strType = Object.prototype.toString.call(obj);\n      return classToType[strType] || \"object\";\n    };\n  })();\n  utils.defaultForType = function(type) {\n    return {\n      string: '',\n      number: 0,\n      \"null\": null,\n      object: {},\n      integer: 0,\n      boolean: false,\n      array: []\n    }[type];\n  };\n  if (typeof TreemaNode !== 'undefined') {\n    return TreemaNode.utils = utils;\n  } else if (typeof module !== 'undefined' && module.exports) {\n    return module.exports = utils;\n  } else {\n    return utils;\n  }\n})();\n;\n//# sourceMappingURL=treema.js.map"]}